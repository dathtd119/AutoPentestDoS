
const performGetRequestLoop = (url, duration) => {
    return new Promise((resolve, reject) => {
        const latencies = [];
        let totalRequests = 0;
        let successfulRequests = 0;
        const endTime = Date.now() + duration * 1000;
        const stopTime = endTime;

        const fetchLoop = async () => {
            while (Date.now() < stopTime) {
                totalRequests++;
                const startTime = Date.now();
                try {
                    await Promise.race([
                        fetch(url),
                        new Promise((_, reject) =>
                            setTimeout(() => reject(new Error('Fetch timeout')), 1000)
                        ),
                    ]);
                    const latency = Date.now() - startTime;
                    latencies.push(latency);
                    successfulRequests++;
                } catch (error) {
                    console.log(`Fetch failed, attack on ${url} successful`);
                    latencies.push(9999); // Push a default value for failed requests
                }
            }

            const maxPing = Math.max(...latencies);
            const minPing = Math.min(...latencies.filter(latency => latency !== 9999));
            const avgPing = latencies.reduce((sum, latency) => sum + latency, 0) / latencies.length;
            const packetLossPercentage = ((totalRequests - successfulRequests) / totalRequests) * 100;

            const results = { maxLatency, averageLatency, minLatency, packetLossPercentage };
            console.log(results);
            process.exit(); // Exit the process after logging the results
        };

        fetchLoop().catch(reject);
    });
};

const getHighResolutionTime = () => {
    const hr = process.hrtime();
    return hr[0] * 1e9 + hr[1];
};

const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const getGetTest = (url, durationInSeconds) => {
    console.log("go to getGetTest");
    return new Promise((resolve, reject) => {
        const latencies = [];
        let totalRequests = 0;
        let successfulRequests = 0;
        const endTime = Date.now() + durationInSeconds * 1000;
        const stopTime = endTime - 1500; // Stop 1.5 seconds before the end

        const fetchLoop = async () => {
            console.log("Performing fetchLoop...");
            let lastFetchTime = Date.now(); // Track the time of the last fetch

            while (Date.now() < stopTime) {
                const now = Date.now();
                const timeSinceLastFetch = now - lastFetchTime;

                // Wait for 2 seconds since the last fetch before making a new request
                if (timeSinceLastFetch >= 2000) {
                    totalRequests++;
                    const startTime = getHighResolutionTime();
                    try {
                        await sleep(100); // Artificial delay of 100 milliseconds
                        console.log('Fetching...'); // Added this line for debugging
                        await Promise.race([
                            fetch(url),
                            new Promise((_, reject) =>
                                setTimeout(() => reject(new Error('Fetch timeout')), 1000)
                            ),
                        ]);
                        console.log('Fetch successful'); // Added this line for debugging
                        const endTime = getHighResolutionTime();
                        const latency = endTime - startTime;
                        console.log('Latency (nanoseconds):', latency);
                        latencies.push(latency);
                        successfulRequests++;
                        lastFetchTime = now; // Update the time of the last successful fetch
                    } catch (error) {
                        console.error('Error during fetch:', error);
                    }
                }
            }

            const max = latencies.length > 0 ? (Math.max(...latencies) / 1e9).toFixed(3) : 9999.000;
            const min = latencies.length > 0 ? (Math.min(...latencies) / 1e9).toFixed(3) : 9999.000;
            const avg = latencies.length > 0 ? (latencies.reduce((sum, latency) => sum + latency, 0) / latencies.length / 1e9).toFixed(3) : 9999.000;
            const packetLossPercentage = ((totalRequests - successfulRequests) / totalRequests) * 100;

            console.log('Resolving Promise...'); // Added this line for debugging
            resolve({ max, avg, min, packetLossPercentage });
        };

        fetchLoop().catch(reject);
    });
};

// Example usage
getGetTest('https://google.com/', 5)
    .then((results) => {
        console.log(results);
    })
    .catch((error) => {
        console.error('Error:', error);
    });