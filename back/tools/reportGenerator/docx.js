

// PizZip is required because docx/pptx/xlsx files are all zipped files, and
// the PizZip library allows us to load the file in memory
const PizZip = require("pizzip");

const fs = require("fs");
const path = require("path");

// const templateFile = "./tools/reportGenerator/report-format.docx";
const templateFile = path.join(__dirname, 'report-format.docx');


const Docxtemplater = require("docxtemplater");


function generateAttackDetails(result) {
    const attackDetails = [];
    const seenLayerMainTypes = new Set(); // Set to track unique combinations of attack_layer and attack_mainType
  
    // Loop through the top-level objects
    result.forEach(layerObject => {
      // Get the layer name and details array
      const [layer, details] = Object.entries(layerObject)[0];
  
      // Loop through the details array for the current layer
      details.forEach(detail => {
        // Get the tool name and attack details
        const toolName = Object.keys(detail)[0];
        const attackInfo = Object.values(detail)[0];
  
        // Loop through the main attack types (Flood, Other, etc.)
        Object.entries(attackInfo).forEach(([attack_mainType, attacks]) => {
          const layerMainTypeKey = `${layer}:${attack_mainType}`; // Unique key for the attack_layer and attack_mainType combination
  
          // Check if the combination has been seen before
          if (!seenLayerMainTypes.has(layerMainTypeKey)) {
            seenLayerMainTypes.add(layerMainTypeKey); // Add the combination to the Set
  
            // Create an object for the main attack type
            const mainTypeObj = {
              attack_layer: layer,
              attack_mainType,
              attack_type: []
            };
  
            // Loop through the individual attack types
            Object.entries(attacks).forEach(([attackType, attackDetails]) => {
              // Create an object for each attack type
              const attackObj = {
                attackType,
                toolName,
                attack_details: [
                  {
                    isSuccess: attackDetails.success ? 'Success' : 'Failure',
                    attack_avg: attackDetails.avgPing,
                    attack_max: attackDetails.maxPing,
                    attack_packetLoss: attackDetails.packetLossPercentage
                  }
                ]
              };
  
              // Add the attack object to the attack_type array
              mainTypeObj.attack_type.push(attackObj);
            });
  
            // Add the main type object to the attackDetails array
            attackDetails.push(mainTypeObj);
          }
        });
      });
    });
  
    return attackDetails;
  }


function generate(init,recon,dos,ddos,OUTPUT_DIR,type) {

    console.log("start build docx...");


    // Load the docx file as binary content
    const content = fs.readFileSync(
        path.resolve(__dirname, templateFile),
        "binary"
    );

    // Unzip the content of the file
    const zip = new PizZip(content);

    // This will parse the template, and will throw an error if the template is
    // invalid, for example, if the template is "{user" (no closing tag)
    const doc = new Docxtemplater(zip, {
        paragraphLoop: true,
        linebreaks: true,
    });


    const attackDetailsDoS = generateAttackDetails(dos.result);
    console.log("attackDetailsDoS:", attackDetailsDoS);

    const attackDetailsDDoS = generateAttackDetails(ddos.result);
    console.log("attackDetailsDDoS:", attackDetailsDDoS);

    console.log("recon:", recon);



    // Render the document (Replace {first_name} by John, {last_name} by Doe, ...)
    doc.render({
        init_address: (init.hostName)?(init.hostName):(init.ip),
        init_scannedDate: init.scannedDate,
        init_scannedTime: init.scannedTime,


        recon_scannedDate: recon.scannedTime,
        reconPorts: recon.ports.map(port => ({
            reconPort_number: port.portId,
            reconPort_service_name: port.name,
            reconPort_service_product: port.product,
            reconPort_service_version: port.version
          })),

        
        dos: attackDetailsDoS,
        ddos: attackDetailsDDoS


    });

    // Get the zip document and generate it as a nodebuffer
    const buf = doc.getZip().generate({
        type: "nodebuffer",
        // compression: DEFLATE adds a compression step.
        // For a 50MB output document, expect 500ms additional CPU time
        compression: "DEFLATE",
    });



    // buf is a nodejs Buffer, you can either write it to a
    // file or res.send it with express for example.
    const fileName = `${init.id}-report.docx`;
    fs.writeFileSync(path.join(OUTPUT_DIR, fileName), buf);


    console.log("Report generated: " + fileName);
    return;
}


module.exports = {
    generate
}