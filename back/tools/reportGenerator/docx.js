

// PizZip is required because docx/pptx/xlsx files are all zipped files, and
// the PizZip library allows us to load the file in memory
const PizZip = require("pizzip");

const fs = require("fs");
const path = require("path");

const templateFile = path.join(__dirname, 'report-format.docx');
const Docxtemplater = require("docxtemplater");
const { title } = require("process");


function generateAttackDetails(result) {
  const attackDetails = [];
  const seenLayerMainTypes = new Set(); // Set to track unique combinations of attack_layer and attack_mainType

  // Loop through the top-level objects
  result.forEach(layerObject => {
    // Get the layer name and details array
    const [layer, details] = Object.entries(layerObject)[0];

    // Loop through the details array for the current layer
    details.forEach(detail => {
      // Get the tool name and attack details
      const toolName = Object.keys(detail)[0];
      const attackInfo = Object.values(detail)[0];

      // Loop through the main attack types (Flood, Other, etc.)
      Object.entries(attackInfo).forEach(([attack_mainType, attacks]) => {
        const layerMainTypeKey = `${layer}:${attack_mainType}`; // Unique key for the attack_layer and attack_mainType combination

        // Check if the combination has been seen before
        if (!seenLayerMainTypes.has(layerMainTypeKey)) {
          seenLayerMainTypes.add(layerMainTypeKey); // Add the combination to the Set

          // Create an object for the main attack type
          const mainTypeObj = {
            attack_layer: layer,
            attack_mainType,
            attack_type: []
          };

          // Loop through the individual attack types
          Object.entries(attacks).forEach(([attackType, attackDetails]) => {
            // Create an object for each attack type
            const attackObj = {
              attackType,
              toolName,
              attack_details: [
                {
                  isSuccess: attackDetails.success ? 'Success' : 'Failure',
                  attack_avg: attackDetails.avgPing,
                  attack_max: attackDetails.maxPing,
                  attack_packetLoss: attackDetails.packetLossPercentage
                }
              ]
            };

            // Add the attack object to the attack_type array
            mainTypeObj.attack_type.push(attackObj);
          });

          // Add the main type object to the attackDetails array
          attackDetails.push(mainTypeObj);
        }
      });
    });
  });

  return attackDetails;
}


function countCvesByPort(jsonData) {
  const each = {};
  let total = 0;
  // console.log(jsonData.ports);

  jsonData.ports.forEach((port) => {
    const cveCount = port.cve ? port.cve.length : 0;
    each[port.portId] = cveCount;
    total += cveCount;
  });
  return { each, total };
}


function countAttackStatus(data, isSuccessful) {
  let count = 0;

  function traverseObject(obj) {
    for (const key in obj) {
      if (typeof obj[key] === 'object' && obj[key] !== null) {
        traverseObject(obj[key]);
      } else if (key === 'success') {
        if (obj[key] === isSuccessful) {
          count++;
        }
      }
    }
  }

  traverseObject(data);
  return count;
}

function countAttackSuccessByLayer(data, layer) {
  let count = 0;

  function traverseObject(obj) {
    for (const key in obj) {
      console.log("key ", key);
      if (Array.isArray(obj[key])) {
        for (const item of obj[key]) {
          console.log("item ", item);
          traverseObject(item);
        }
      } else if (typeof obj[key] === 'object' && obj[key] !== null) {
        traverseObject(obj[key]);
      } else if (key === 'success' && obj[key] === true) {
        console.log("success KEY? ", obj[key]);
        if (isInLayer(obj, layer)) {
          
        }
        count++;
      }
    }
  }

  function isInLayer(obj, targetLayer) {
    for (const key in obj) {
      if (key === targetLayer) {
        return true;
      } else if (typeof obj[key] === 'object' && obj[key] !== null) {
        if (isInLayer(obj[key], targetLayer)) {
          return true;
        }
      }
    }
    return false;
  }

  traverseObject(data.result[0]);
  console.log("count ", count);
  return count;
}







function generate(init, recon, dos, ddos, OUTPUT_DIR) {

  console.log("start build docx...");


  // Load the docx file as binary content
  const content = fs.readFileSync(
    path.resolve(__dirname, templateFile),
    "binary"
  );

  // Unzip the content of the file
  const zip = new PizZip(content);

  // This will parse the template, and will throw an error if the template is
  // invalid, for example, if the template is "{user" (no closing tag)
  const doc = new Docxtemplater(zip, {
    paragraphLoop: true,
    linebreaks: true,
  });


  const attackDetailsDoS = generateAttackDetails(dos.result);
  // console.log("attackDetailsDoS:", attackDetailsDoS);

  const attackDetailsDDoS = generateAttackDetails(ddos.result);
  // console.log("attackDetailsDDoS:", attackDetailsDDoS);

  // console.log("recon:", recon);

  const { each: reconPortCount, total: sum_recon_cveCount } = countCvesByPort(recon);



  // Render the document (Replace {first_name} by John, {last_name} by Doe, ...)
  doc.render({
    init_address: (init.hostName) ? (init.hostName) : (init.ip),
    init_scannedDate: init.scannedDate,
    init_scannedTime: init.scannedTime,

    sum_recon_portCount: recon.ports.length,
    sum_recon_cveCount: sum_recon_cveCount,
    
    sum_exploit_affect: countAttackStatus(recon, true),
    sum_exploit_affect_dos_layer3: countAttackSuccessByLayer(dos, "Layer 3"),
    sum_exploit_affect_dos_layer4: countAttackSuccessByLayer(dos, "Layer 4"),
    sum_exploit_affect_dos_layer7: countAttackSuccessByLayer(dos, "Layer 7"),

    sum_exploit_affect_ddos_layer3: countAttackSuccessByLayer(ddos, "Layer 3"),
    sum_exploit_affect_ddos_layer4: countAttackSuccessByLayer(ddos, "Layer 4"),
    sum_exploit_affect_ddos_layer7: countAttackSuccessByLayer(ddos, "Layer 7"),

    recon_scannedDate: recon.scannedTime,
    reconPorts: recon.ports.map(port => ({
      reconPort_number: port.portId,
      reconPort_service_name: port.name,
      reconPort_service_product: port.product,
      reconPort_service_version: port.version
    })),


    dos: attackDetailsDoS,
    ddos: attackDetailsDDoS


  });

  // Get the zip document and generate it as a nodebuffer
  const buf = doc.getZip().generate({
    type: "nodebuffer",
    // compression: DEFLATE adds a compression step.
    // For a 50MB output document, expect 500ms additional CPU time
    compression: "DEFLATE",
  });



  // buf is a nodejs Buffer, you can either write it to a
  // file or res.send it with express for example.
  const fileName = `${init.id}-report.docx`;
  fs.writeFileSync(path.join(OUTPUT_DIR, fileName), buf);


  console.log("Report generated: " + fileName);
  return;
}


module.exports = {
  generate
}