


let shell = require('shelljs')
const { spawnSync } = require('child_process');




const fs = require('fs');
const path = require('path');

const RECON_DIR = './output/'
const NMAP_FORMATTER_DIR    = './tools/recon/nmap-formatter'
const CVEMAP_DIR            = './tools/recon/cvemap'








async function getCveDetails(exploitInfo) {
  console.log('Starting getCveDetails function...');

  const result = await Promise.all(exploitInfo.map(async item => {
      console.log(`Processing "SEARCH": ${item.SEARCH}`);
      const product = { Product: item.SEARCH };
      const cveDetails = (await Promise.all(item.RESULTS_EXPLOIT.filter(exploit => exploit.Type === 'dos').map(async exploit => {
          // console.log(`Processing "RESULTS_EXPLOIT" for "${item.SEARCH}": ${exploit.Title}`);
          let codes = exploit.Codes;
          // Check if codes is not undefined before checking for semicolon
          if (codes !== undefined) {
              if (codes.includes(';')) {
                  console.log(`"Codes" field contains multiple codes: ${codes}`);
                  codes = codes.split(';').find(code => code.startsWith('CVE-'));
                  console.log(`Extracted CVE code: ${codes}`);
              } else if (codes.startsWith('OSVDB-')) {
                  console.log(`"Codes" field is an OSVDB code, bypassing: ${codes}`);
                  return null;
              } else if (codes === '' || codes === null) {
                  console.log(`"Codes" field is empty, bypassing: ${codes}`);
                  return null;
              }
          } else {
              console.log(`"Codes" field is undefined, bypassing`);
              return null;
          }

          if (codes) {
              try {
                  const cveDetailss = await getCveMapDetails(codes);
                  console.log(`Getting details : ${codes}`);
                  return {
                      Codes: codes,
                      Title: exploit.Title,
                      Details: cveDetailss
                  };
              } catch (error) {
                  console.error(`Error fetching CVE details for ${codes}: ${error.toString()}`);
                  return {
                      Codes: codes,
                      Title: exploit.Title,
                      Details: {}
                  };
              }
          } else {
              console.log(`No valid CVE code found for "${exploit.Title}"`);
              return null;
          }
      }))).reduce((acc, val) => val ? acc.concat(val) : acc, []);;

      return {
          ...product,
          Cve: cveDetails
      };
  }));

  console.log('getCveDetails function completed.');
  return result;
}
  
async function getCveMapDetails(cveId) {
  console.log(`Executing cvemap tool for CVE: ${cveId}`);
  try {
    const args = ['-id', cveId, '-silent', '-json'];
    const result = await spawnSync('bash', ['-c', `${CVEMAP_DIR} ${args.join(' ')}`]);
    // console.error('stderr:', result.stderr.toString());
    return JSON.parse(result.stdout.toString());
  } catch (error) {
    console.error(`Error fetching CVE details for ${cveId}: ${error}`);
    return {};
  }
}





async function fixSearchSploitJson(data) {
    // Replace the pattern with a comma between the two objects
    const fixedData = data.replace(/}\s*{/g, '},\n{');
  
    // Convert the fixed data to an array of objects
    const jsonArray = JSON.parse(`[${fixedData}]`);
  
    // Find unique "SEARCH" entries
    const searchEntries = new Set(jsonArray.map(obj => obj.SEARCH));
    const uniqueSearchEntries = [...searchEntries].reverse();
    // console.log('Details:');
    // console.log('Unique "SEARCH" entries:', uniqueSearchEntries);
  
    // Create a new array with unique "SEARCH" entries
    const result = uniqueSearchEntries.reduce((acc, search) => {
      let filteredObjects = jsonArray.filter(obj => obj.SEARCH === search);
  
      // If "RESULTS_EXPLOIT" is empty, go up a level
      while (filteredObjects.length > 0 && filteredObjects[filteredObjects.length - 1].RESULTS_EXPLOIT.length === 0) {
        filteredObjects.pop();
      }
  
      // Get only "RESULTS_EXPLOIT" entries with "Type" : "dos"
    filteredObjects = filteredObjects.map(obj => ({
        ...obj,
        RESULTS_EXPLOIT: obj.RESULTS_EXPLOIT.filter(result => {
          // Handle the "Codes" field
          if (result.Codes === '') {
            return false; // Delete the entry
          } else if (result.Codes.includes(';')) {
            const codes = result.Codes.split(';');
            result.Codes = codes.find(code => code.startsWith('CVE-')); // Keep only the CVE code
            return true;
          } else {
            return result.Type === 'dos';
          }
        })
      }));
  
      // Get the last object with non-empty "RESULTS_EXPLOIT"
      const finalObject = filteredObjects[filteredObjects.length - 1] || null;
  
      // If the final object has "RESULTS_EXPLOIT", add it to the result
      if (finalObject && finalObject.RESULTS_EXPLOIT.length > 0) {
        return [...acc, finalObject];
      }
  
      return acc;
    }, []);
  
    return result;
  }



async function runScan(id, ip) {
    console.log("---> Go to Recon...");


    const nmapXMLFile = `${id}-nmap.xml`;
    const nmapJSONFile = `${id}-recon-nmap.json`;
    const cveInfoFile = `${id}-recon-cve.json`;


    const cmdNmap = `nmap -A ${ip} -sV -T4 --allports --version-intensity 7 --max-retries 2 --scan-delay 0 -oX ${path.join(RECON_DIR, nmapXMLFile)}`;
    const cmdParseXMLToJSON = `${NMAP_FORMATTER_DIR} json ${path.join(RECON_DIR, nmapXMLFile)} -f ${path.join(RECON_DIR, nmapJSONFile)}`;
    const cmdExploitDB = `searchsploit --nmap ${path.join(RECON_DIR, nmapXMLFile)} --json`;
    const removeXMLAfterParse = `rm ${path.join(RECON_DIR, nmapXMLFile)}`;
  

    try {

        // Run Nmap
        console.log("-------------------------------------------");
        console.log(`---> Performing nmap on ID: ${id}...`);
        await shell.exec(cmdNmap, { silent: true });
        console.log("nmap successful.");
        console.log("-------------------------------------------");

        // Parse Nmap XML to JSON
        console.log("start parsing Nmap XML to JSON...");
        await shell.exec(cmdParseXMLToJSON, { silent: true });
        console.log("parsing Nmap XML to JSON successful.");
        console.log("-------------------------------------------");

        // Run ExploitDB
        console.log("start running ExploitDB...");
        const exploitDBOutput = await shell.exec(cmdExploitDB, { silent: true });
        console.log("running ExploitDB successful.");
        console.log("-------------------------------------------");

        // Run FixSearchSploitJson
        console.log("start Fixing Searchsploit Json...");
        const exploitInfo = await fixSearchSploitJson(exploitDBOutput.stdout);
        console.log("Fixing Searchsploit Json successful.");
        console.log("-------------------------------------------");
        
        // Fetch CVE details
        console.log("start fetching CVE details...");
        const cveInfo = await getCveDetails(exploitInfo);

        await fs.writeFile(path.join(RECON_DIR, cveInfoFile), JSON.stringify(cveInfo, null, 2), (err) => {
        if (err) {
            console.error('Error writing file:', err);
        } else {
            console.log(cveInfoFile + ' file written successfully.');
        }
        });
    

      // Remove Nmap XML after parse
      console.log("start removing Nmap XML after parse...");
      await shell.exec(removeXMLAfterParse, { silent: true });
      console.log('All commands executed successfully.');
      console.log("-------------------------------------------");


    } catch (error) {
      console.error("runScan error: ", error.toString());
    }
  }



module.exports = {
    runScan
}
