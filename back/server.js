const PORT = 3001;


const child_process = require('child_process');
const shell = require('shelljs');
const DEF_ATTACK_DURATION = 10;
const DEF_ATTACK_THREADS = 100;
const DEF_ATTACK_SOCKTYPE = 0;



const DIR_OUTPUT = "./output/";
const DIR_RECON = "./tools/recon/recon";


// const RECON = require(DIR_RECON);

const attackBase = require("./tools/attack/attackbase");

const HPING3 = require("./tools/attack/hping3/hping3");
const MHDDOS = require("./tools/attack/mhddos/mhddos");




const docx = require("./tools/reportGenerator/docx");

const libre = require('libreoffice-convert');
libre.convertAsync = require('util').promisify(libre.convert);

const express = require('express')
var cors = require('cors')
const app = express()

app.use(cors())
app.use(express.json())
app.use(express.urlencoded({ extended: true }))

const validator = require('validator');

const e = require('express')
const fs = require('fs');
const path = require('path');
const { json } = require("express");

const scanDes = {
  id: "",
  hostName: "",
  ip: "",
  scannedTime: "",
  duration: "",
  threads: "",
  scanList: [],
  doneList: [],
  initPing: [],
  initGet: []
};


//This function runs the scans in parallel
const runScansInParallel = async (id, ip) => {
  return new Promise((resolve, reject) => {
    const child = child_process.fork(DIR_RECON);
    child.send({ type: 'runScan', id, ip });
    child.on('message', (message) => {
      if (message.type === 'done') {
        resolve(message.data);
        child.kill();
      } else if (message.type === 'error') {
        reject(message.error);
        child.kill();
      }
    });
    child.on('exit', (code, signal) => {
      if (code !== 0 && signal !== null) {
        reject(new Error(`Child process exited with code ${code} and signal ${signal}`));
      }
    });
  });
};




async function writeInitFile(jsonData) {
  const filePath = `${DIR_OUTPUT}${jsonData.id}-init.json`;

  try {
    if (!fs.existsSync(filePath)) {
      // Create a new file with the provided jsonData
      await fs.promises.writeFile(filePath, JSON.stringify(jsonData, null, 2));
    } else {
      // If the file exists, overwrite it with the new jsonData
      await fs.promises.writeFile(filePath, JSON.stringify(jsonData, null, 2));
    }
  } catch (error) {
    console.error('Error writing JSON file:', error);
  }
}


async function writeDoneList(victim, scanTypeId) {
  const filePath = `${DIR_OUTPUT}${victim.id}-init.json`;
  await notify(victim.id, scanTypeId);
  try {
    // Read the existing JSON data from the file
    const jsonData = JSON.parse(await fs.promises.readFile(filePath, 'utf8'));

    // Check if the scanTypeId is already in the doneList array
    if (!jsonData.doneList.includes(scanTypeId)) {
      // If not, add it to the doneList array
      jsonData.doneList.push(scanTypeId);

      // Write the updated JSON data back to the file
      await fs.promises.writeFile(filePath, JSON.stringify(jsonData, null, 2));
      console.log(`Scan type ${scanTypeId} added to doneList for victim ${victim.id}`);
    } else {
      console.log(`Scan type ${scanTypeId} is already in doneList for victim ${victim.id}`);
    }
  } catch (error) {
    console.error(`Error updating JSON file for victim ${victim.id}:`, error);
  }
}

async function writeInitPing(victimID, result) {
  const filePath = `${DIR_OUTPUT}${victimID}-init.json`;

  try {
    // Read the existing JSON data from the file
    const jsonData = JSON.parse(await fs.promises.readFile(filePath, 'utf8'));

    // Update the initPing object with the provided ping results
    jsonData.initPing = {
      minPing: result.min || null,
      avgPing: result.avg || null,
      maxPing: result.max || null,
      packetLossPercentage: result.packetLossPercentage
    };

    // Write the updated JSON data back to the file
    await fs.promises.writeFile(filePath, JSON.stringify(jsonData, null, 2));
    console.log(`Ping results updated for victim ${victimID}`);
  } catch (error) {
    console.error(`Error updating JSON file for victim ${victimID}:`, error);
  }
}





















async function notify(title, body) {
  fetch('https://ntfy.sh/gsp24ia08-capstone-webapp', {
    method: 'POST', // PUT works too
    body: body,
    headers: {
      'Title': title,
    }
  })
}






function getInfoByType(scanId, type) {
  const filePath = `${DIR_OUTPUT}${scanId}-${type}.json`; // Use template literal for flexibility
  try {
    const data = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(data);
  } catch (err) {
    if (err.code === 'ENOENT') { // Handle file not found error
      return { error: 'Scan not found' };
    } else {
      throw err; // Re-throw other errors
    }
  }
}


function getReconDetails(scanId) {
  const scanData = getInfoByType(scanId, 'recon-nmap');
  const cveData = getInfoByType(scanId, 'recon-cve');

  if ('error' in scanData) return scanData;

  if (!Array.isArray(scanData.Host) || scanData.Host.length === 0) {
    return { error: 'No host found in the scan data.' };
  }

  const firstHost = scanData.Host[0];
  if (!Array.isArray(firstHost.Port)) {
    return { error: 'No port data found for the host.' };
  }

  const ports = firstHost.Port.sort((a, b) => a.PortID - b.PortID);

  const portDetails = ports
    .filter(port => port.Service && port.Service.Product) // Skip ports with null or undefined Service or Product
    .map(port => {
      const scripts = port.Script ? port.Script.map(script => ({ id: script.ID, output: script.Output })) : [];

      // Filter CVE data based on the product name
      const cveForProduct = cveData
        .filter(cve => cve.Product.toLowerCase().includes(port.Service.Product.toLowerCase()))
        .flatMap(cve => cve.Cve);

      // Remove duplicates based on the "Codes" property
      const uniqueCves = cveForProduct.filter((cve, index, self) =>
        index === self.findIndex(t => t.Codes === cve.Codes)
      );

      return {
        portId: port.PortID,
        name: port.Service.Name,
        product: port.Service.Product,
        version: port.Service.Version,
        cve: uniqueCves,
        scripts: scripts
      };
    });

  return {
    id: scanId,
    scannedTime: scanData.StartStr,
    address: firstHost.HostAddress[0].Address,
    hostName: firstHost.HostNames.HostName ? firstHost.HostNames.HostName[0].Name : null,
    ports: portDetails
  };
}



function getReconDetailsReport(scanId) {
  const scanData = getInfoByType(scanId, 'recon');

  if ('error' in scanData) return scanData;

  // Check if the Host array has at least one element
  if (!Array.isArray(scanData.Host) || scanData.Host.length === 0) {
    return {
      error: 'No host found in the scan data.'
    };
  }

  // Check if the first host has a Port property that is an array
  const firstHost = scanData.Host[0];
  if (!Array.isArray(firstHost.Port)) {
    return {
      error: 'No port data found for the host.'
    };
  }

  // Get ports
  const ports = firstHost.Port
    .sort((a, b) => a.PortID - b.PortID);

  // Map ports to details
  const portDetails = ports.map(port => {
    const scripts = port.Script ? port.Script.map(script => ({
      id: script.ID,
      output: script.Output
    })) : [];

    return {
      portId: port.PortID,
      name: port.Service.Name,
      product: port.Service.Product,
      version: port.Service.Version,
      scripts: scripts
    };
  });

  return {
    id: scanId,
    scannedTime: scanData.StartStr,
    address: firstHost.HostAddress[0].Address,
    hostName: firstHost.HostNames.HostName ? firstHost.HostNames.HostName[0].Name : null,
    ports: portDetails
  };
}


async function getInitDetails(scanId) {
  try {
    const filePath = path.join(DIR_OUTPUT, `${scanId}-init.json`);
    const jsonContent = fs.readFileSync(filePath, 'utf8');
    const parsedData = JSON.parse(jsonContent);

    // Extract the initPing object
    return parsedData;
  } catch (error) {
    console.error('Error reading init details:', error);
    return null;
  }
}

async function getInitPingDetails(scanId) {
  try {
    const filePath = path.join(DIR_OUTPUT, `${scanId}-init.json`);
    const jsonContent = fs.readFileSync(filePath, 'utf8');
    const parsedData = JSON.parse(jsonContent);

    // Extract the initPing object
    const initPing = parsedData.initPing;
    return initPing;
  } catch (error) {
    console.error('Error reading initPing details:', error);
    return null;
  }
}

async function getInitGetDetails(scanId) {
  try {
    const filePath = path.join(DIR_OUTPUT, `${scanId}-init.json`);
    const jsonContent = fs.readFileSync(filePath, 'utf8');
    const parsedData = JSON.parse(jsonContent);

    // Extract the initPing object
    const initGet = parsedData.initGet;
    return initGet;
  } catch (error) {
    console.error('Error reading initGet details:', error);
    return null;
  }
}





function getReconInfo(scanId) {
  const filePath = `${DIR_OUTPUT}${scanId}-recon-nmap.json`; // Use template literal for flexibility

  try {
    const data = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(data);
  } catch (err) {
    if (err.code === 'ENOENT') { // Handle file not found error
      return { error: 'Scan not found' };
    } else {
      throw err; // Re-throw other errors
    }
  }
}


//Generate Scan ID
function generateID() {
  // Get the list of files in the ./scanned folder
  const files = fs.readdirSync('./output');
  // Find the largest number in filenames of files ending with '-recon-nmap.json'
  let maxId = 0;
  files.forEach((file) => {
    if (file.endsWith('-recon-nmap.json')) {
      const fileId = parseInt(path.parse(file).name.replace('-recon', ''));
      if (!isNaN(fileId) && fileId > maxId) {
        maxId = fileId;
      }
    }
  });
  // Increment the largest number by 1
  return (maxId + 1).toString();
}


function getIpById(id) {
  try {
    const filename = `${id}-recon-nmap.json`;
    const filePath = path.join('./output', filename);

    // Read the JSON file
    const data = fs.readFileSync(filePath, 'utf8');
    const jsonData = JSON.parse(data);

    // Find the first "Address" in the "HostAddress" array
    const address = jsonData.Host[0].HostAddress.find(addr => addr.AddressType === 'ipv4').Address;

    return address;
  } catch (err) {
    console.error(`Error reading file ${id}-init.json:`, err);
    return null;
  }
}


function getRecentScans() {
  try {
    const files = fs.readdirSync(DIR_OUTPUT);
    // Filter JSON files
    const jsonFiles = files.filter((filename) => filename.endsWith('-init.json'));
    if (jsonFiles.length === 0) {
      // Handle empty directory (no JSON files)
      return [];
    }

    // Process JSON files (e.g., read content, parse data, etc.)
    const allScans = jsonFiles.map((filename) => {
      const filePath = path.join(DIR_OUTPUT, filename);
      const jsonContent = fs.readFileSync(filePath, 'utf8');
      try {
        const parsedData = JSON.parse(jsonContent);

        // Extract the required properties
        const victimData = {
          id: parsedData.id,
          hostName: parsedData.hostName,
          ip: parsedData.ip,
          startTime: parsedData.scannedTime,
          scannedDate: parsedData.scannedDate,
          duration: parsedData.duration,
          threads: parsedData.threads,
          scanList: parsedData.scanList,
          doneList: parsedData.doneList
        };

        return victimData;
      } catch (parseError) {
        console.error('Error parsing JSON:', parseError);
        return { error: 'Failed to parse JSON' };
      }
    }).flat();

    return allScans;
  } catch (error) {
    console.error('Error reading scanned directory:', error);
    return { error: 'Failed to retrieve scans' };
  }
}


const getHostOrIP = (victimData, urlType = 0) => {
  let hostOrIP;

  if (victimData.hostName && victimData.hostName !== "") {
    hostOrIP = victimData.hostName;
  } else {
    hostOrIP = victimData.ip;
  }

  // Check if the hostOrIP already has a protocol prefix
  const hasProtocolPrefix = hostOrIP.startsWith("http://") || hostOrIP.startsWith("https://");

  switch (urlType) {
    case 0:
      // No prefix
      if (hasProtocolPrefix) {
        // Remove the protocol prefix
        hostOrIP = hostOrIP.replace(/^https?:\/\//, '');
      }
      break;
    case 1:
      // Add http://
      if (!hasProtocolPrefix) {
        hostOrIP = `http://${hostOrIP}`;
      }
      break;
    case 2:
      // Add https://
      if (!hasProtocolPrefix) {
        hostOrIP = `https://${hostOrIP}`;
      }
      break;
    default:
      console.error(`Invalid urlType: ${urlType}`);
  }

  return hostOrIP;
};


const handleSingleScanType = async (scanType, victimData, duration, threads, initPing, initPingLayer7) => {
  let isHostDown = false;

  switch (scanType) {
    case 10:
      // Perform recon
      // await RECON.runScan(victimData.id, getHostOrIP(victimData));
      // writeDoneList(victimData, scanType);
      // break;

      await runScansInParallel(victimData.id, getHostOrIP(victimData));
      writeDoneList(victimData, scanType);
      break;


    case 231:
      // DoS Layer 3 - Flood
      await HPING3.dosLayer3Flood(victimData.id, getIpById(victimData.id), duration, threads, initPing);
      writeDoneList(victimData, scanType);
      isHostDown = await attackBase.checkTargetDownusingPing(getHostOrIP(victimData, 0), duration, initPing);
      break;


    case 241:
      // DoS Layer 4 - Flood
      await HPING3.dosLayer4Flood(victimData.id, getIpById(victimData.id), duration, threads, initPing);
      writeDoneList(victimData, scanType);
      isHostDown = await attackBase.checkTargetDownusingPing(getHostOrIP(victimData, 0), duration, initPing);
      break;
    case 271:
      // DoS Layer 7 - Flood
      await MHDDOS.dosLayer7Flood(victimData.id, getIpById(victimData.id), duration, threads, initPingLayer7, DEF_ATTACK_SOCKTYPE);
      writeDoneList(victimData, scanType);
      isHostDown = await attackBase.checkTargetDownUsingGet(getHostOrIP(victimData, 1), duration, initPingLayer7);
      break;
    case 274:
      // DoS Layer 7 - Other
      await MHDDOS.dosLayer7Other(victimData.id, getIpById(victimData.id), duration, threads, initPingLayer7, DEF_ATTACK_SOCKTYPE);
      writeDoneList(victimData, scanType);
      isHostDown = await attackBase.checkTargetDownUsingGet(getHostOrIP(victimData, 1), duration, initPingLayer7);
      break;




    case 331:
      // DDoS Layer 3 - Flood
      await HPING3.ddosLayer3Flood(victimData.id, getIpById(victimData.id), duration, threads, initPing);
      writeDoneList(victimData, scanType);
      isHostDown = await attackBase.checkTargetDownusingPing(getHostOrIP(victimData, 0), duration, initPing);
      break;
    case 341:
      // DDoS Layer4 - Flood
      await HPING3.ddosLayer4Flood(victimData.id, getIpById(victimData.id), duration, threads, initPing);
      writeDoneList(victimData, scanType);
      isHostDown = await attackBase.checkTargetDownusingPing(getHostOrIP(victimData, 0), duration, initPing);
      break;
    case 371:
      // DDoS Layer 7 - Flood
      await MHDDOS.ddosLayer7Flood(victimData.id, getIpById(victimData.id), duration, threads, initPingLayer7, DEF_ATTACK_SOCKTYPE);
      writeDoneList(victimData, scanType);
      isHostDown = await attackBase.checkTargetDownUsingGet(getHostOrIP(victimData, 1), duration, initPingLayer7);
      break;
    case 374:
      // DDoS Layer 7 - Other
      await MHDDOS.ddosLayer7Other(victimData.id, getIpById(victimData.id), duration, threads, initPingLayer7, DEF_ATTACK_SOCKTYPE);
      writeDoneList(victimData, scanType);
      isHostDown = await attackBase.checkTargetDownUsingGet(getHostOrIP(victimData, 1), duration, initPingLayer7);
      break;
    default:
      console.log(`On handleSingleScanType, Invalid scanType number: ${scanType}.`);
  }

  // bro done good :), take a nap.
  await new Promise(resolve => setTimeout(resolve, 500));

};






app.post('/scan', async (req, res) => {
  const inputVictim = req.body.scan;
  let scanType;
  const duration = parseInt(req.body.duration) || DEF_ATTACK_DURATION; // Default duration is 10 seconds
  const threads = parseInt(req.body.threads) || DEF_ATTACK_THREADS; // Default threads is 1000


  let isIP = validator.isIP(inputVictim);
  let isURL = validator.isURL(inputVictim);

  try {
    // Validate IP or URL
    if (!isIP && !isURL) {
      return res.status(400).json({ 'error': 'Invalid input. It should be an IP address or a domain URL.' });
    }

    // Create the JSON data: id, domain, scannedDate
    const dataScan = { ...scanDes };

    // Set IP or Domain
    if (isIP) {
      dataScan.ip = inputVictim;
    } else {
      dataScan.domain = inputVictim;
    }

    dataScan.id = generateID();
    const currentDate = new Date();
    dataScan.scannedDate = currentDate.toISOString().split('T')[0];
    dataScan.scannedTime = currentDate.toLocaleTimeString();

    dataScan.duration = duration;
    dataScan.threads = threads;




    // Check if scanType is an array
    if (Array.isArray(req.body.scanType)) {
      // If it's an array, parse each element to an integer

      scanType = req.body.scanType.map(type => parseInt(type, 10));
    } else {
      // If it's a single value, parse it to an integer
      scanType = parseInt(req.body.scanType, 10);
    }
    dataScan.scanList = scanType;

    console.log("Init Scan data: ", dataScan);
    await writeInitFile(dataScan);

    const initPing = await attackBase.initPing(dataScan.id, dataScan.ip, dataScan.duration);
    console.log("Ping init: ", initPing);
    // await writeInitPing(dataScan.id,initPing);

    const initGet = await attackBase.initGet(dataScan.id, `http://${dataScan.ip}/`, dataScan.duration);
    console.log("Get init: ", initGet);

    res.json({ scanResult: dataScan });

    /// Check if scanType is an array
    if (Array.isArray(scanType)) {
      let performSpecificSwitchCases = false;
      let switchCasesToPerform = [];

      // Check if the array contains 0, 20, or 30
      if (scanType.includes(0)) {
        performSpecificSwitchCases = true;
        switchCasesToPerform = [10, 231, 241, 271, 274, 331, 341, 371, 374];
      } else if (scanType.includes(20)) {
        performSpecificSwitchCases = true;
        switchCasesToPerform = [231, 241, 271, 274];
      } else if (scanType.includes(30)) {
        performSpecificSwitchCases = true;
        switchCasesToPerform = [331, 341, 371, 374];
      }

      // If the array contains 0, 20, or 30, perform the corresponding switch cases
      if (performSpecificSwitchCases) {
        for (const type of switchCasesToPerform) {
          await handleSingleScanType(type, dataScan, duration, threads, initPing, initGet);
        }
      } else {
        // If the array doesn't contain 0, 20, or 30, perform each scan type one by one
        for (const type of scanType) {
          await handleSingleScanType(type, dataScan, duration, threads, initPing, initGet);
        }
      }
    } else {
      // If it's a single value, perform the corresponding scan type
      await handleSingleScanType(scanType, dataScan, duration, threads, initPing, initGet);
    }

    // await scoreAttacks(dataScan.id);

    console.log("---------------------------------------------------------------");
    console.log(`----------------------> DONE ID: ${dataScan.id}.`);
    console.log("---------------------------------------------------------------");

  } catch (error) {
    console.log("Error: ", error);
    res.status(500).json({ 'error': 'Failed to perform scan' });
  }
});





//Retrieve Init Ping results
app.get('/scan/:scanId/initPing', async (req, res) => {
  const scanId = req.params.scanId;

  try {
    const initPingDetails = await getInitPingDetails(scanId);
    if (!initPingDetails) {
      return res.status(404).json({ 'error': 'initPing details not found' });
    }
    res.json(initPingDetails);
  } catch (error) {
    res.status(500).json({ 'error': 'Failed to retrieve initPing details' });
  }
});

app.get('/scan/:scanId/initGet', async (req, res) => {
  const scanId = req.params.scanId;

  try {
    const initGetDetails = await getInitGetDetails(scanId);
    if (!initGetDetails) {
      return res.status(404).json({ 'error': 'initGet details not found' });
    }
    res.json(initGetDetails);
  } catch (error) {
    res.status(500).json({ 'error': 'Failed to retrieve initGet details' });
  }
});








//Retrieve RECON results
app.get('/scan/:scanId/recon', async (req, res) => {
  const scanId = req.params.scanId;

  try {
    const details = await getReconDetails(scanId);
    if (!details) {
      return res.status(404).json({ 'error': 'Scan Recon not found' });
    }
    res.json(details);
  } catch (error) {
    res.status(500).json({ 'error': 'Failed to retrieve scan Recon result' });
  }
});


//Retrieve ATTACK results
app.get('/scan/:scanId/attack/dos', async (req, res) => {
  const scanId = req.params.scanId;

  try {
    const attackResult = await getInfoByType(scanId, "dos");

    if (!attackResult) {
      return res.status(404).json({ 'error': 'dos details not found' });
    }

    res.json(attackResult);
  } catch (error) {
    res.status(500).json({ 'error': 'Failed to retrieve scan Attack result' });
  }
});

app.get('/scan/:scanId/attack/ddos', async (req, res) => {
  const scanId = req.params.scanId;

  try {
    const attackResult = await getInfoByType(scanId, "ddos");

    if (!attackResult) {
      return res.status(404).json({ 'error': 'ddos details not found' });
    }

    res.json(attackResult);
  } catch (error) {
    res.status(500).json({ 'error': 'Failed to retrieve scan Attack result' });
  }
});

app.get('/scan/:scanId/attack/score', async (req, res) => {
  const scanId = req.params.scanId;

  try {
    const details = await getInfoByType(scanId, "score");
    if (!details) {
      return res.status(404).json({ 'error': 'Scan Recon not found' });
    }
    res.json(details);
  } catch (error) {
    res.status(500).json({ 'error': 'Failed to retrieve scan Recon result' });
  }
});





//Retrieve Report file
app.post('/scan/:scanId/report', async (req, res) => {
  const scanId = req.params.scanId;
  const type = req.body.type || 'docx'; // Get the type from query parameter, default to 'docx'

  //Get init details
  const detailsInit = await getInitDetails(scanId);
  if (!detailsInit) {
    return res.status(404).json({ 'error': 'init details not found' });
  }

  const detailsRecon = await getReconDetails(scanId);
  if (!detailsRecon) {
    return res.status(404).json({ 'error': 'Scan Recon not found' });
  }

  //Get DoS results
  const resultDoS = await getInfoByType(scanId, "dos");
  if (!resultDoS) {
    return res.status(404).json({ 'error': 'Scan DoS Attack not found' });
  }

  //Get DDoS results
  const resultDDoS = await getInfoByType(scanId, "ddos");
  if (!resultDDoS) {
    return res.status(404).json({ 'error': 'Scan DDoS Attack not found' });
  }

  await docx.generate(detailsInit, detailsRecon, resultDoS, resultDDoS, DIR_OUTPUT, type);

  //Check the type if pdf, then pdf will be downloaded
  if (type === 'pdf') {
    const outputPath = path.join(DIR_OUTPUT, `${detailsInit.id}-report.pdf`);
    await shell.exec(`libreoffice --convert-to pdf ${DIR_OUTPUT}${detailsInit.id}-report.docx`);
    if (!fs.existsSync(outputPath)) {
      return res.status(404).json({ 'Make report error': 'Report file not found' });
    }
    res.status(200).download(outputPath);
  } else {
    const filePath = path.join(DIR_OUTPUT, `${detailsInit.id}-report.docx`);
    if (!fs.existsSync(filePath)) {
      return res.status(404).json({ 'Make report error': 'Report file not found' });
    }
    res.status(200).download(filePath);
  }
});
















//List recent scans
app.get('/scans', async (req, res) => {
  try {
    // console.log("Getting GET /scans...");
    const recentScans = await getRecentScans();
    res.json(recentScans);
  } catch (error) {
    res.status(500).json({ 'error': 'Failed to retrieve scans' });
  }
});












app.listen(
  PORT,
  () => { console.log(`Server started on http://localhost:${PORT}`) })