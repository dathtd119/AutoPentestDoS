import {
  Button,
  Card,
  Label,
  Form,
  H1, H2, H4,
  Paragraph, SizableText,
  Separator,
  useToastController,
  XStack,
  YStack,
  Checkbox, YGroup, ListItem,
  Tooltip
} from '@my/ui'
import {Input, Spinner} from 'tamagui'
import type { CheckboxProps} from 'tamagui'
import {
  Check as CheckIcon,
  CheckCircle2 as DoneIcon
} from '@tamagui/lucide-icons'
import React, { useState, useEffect } from 'react'
import { useLink } from 'solito/link'

const backendUrl = 'http://localhost:3001'; // Replace with your server URL







const getAllKeys = (data) => {
  const result = [];

  const traverseData = (nodes) => {
    nodes.forEach((node) => {
      result.push(node.key);

      if (node.children) {
        traverseData(node.children);
      }
    });
  };

  traverseData(data);

  // Remove duplicates and sort
  return [...new Set(result)].sort();
};

const scanListCheck = [
  {
    key: '0',
    label: 'Full Scan',
    children: [
      {
        key: '10',
        label: 'Reconnaissance step',
      },
      {
        key: '20',
        label: 'Full DoS attacks',
        children: [
          {
            key: '23',
            label: 'Layer 3',
            children: [
              {
                key: '231',
                label: 'DoS Layer 3 - Flood attacks',
              },
            ],
          },
          {
            key: '24',
            label: 'Layer 4',
            children: [
              {
                key: '241',
                label: 'DoS Layer 4 - Flood attacks',
              },
              // {
              //   key: '242',
              //   label: 'DoS Layer 4 - Amplification attacks',
              // },
              // {
              //   key: '243',
              //   label: 'DoS Layer 4 - Reflection attacks',
              // },
            ],
          },
          {
            key: '27',
            label: 'Layer 7',
            children: [
              {
                key: '271',
                label: 'DoS Layer 7 - Flood attacks',
              },
              // {
              //   key: '272',
              //   label: 'DoS Layer 7 - Amplification attacks',
              // },
              // {
              //   key: '273',
              //   label: 'DoS Layer 7 - Reflection attacks',
              // },
              {
                key: '274',
                label: 'DoS Layer 7 - Other attacks',
              },
            ],
          },
        ],
      },
      {
        key: '30',
        label: 'Full DDoS attacks',
        children: [
          {
            key: '33',
            label: 'Layer 3',
            children: [
              {
                key: '331',
                label: 'DDoS Layer 3 - Flood attacks',
              },
            ],
          },
          {
            key: '34',
            label: 'Layer 4',
            children: [
              {
                key: '341',
                label: 'DDoS Layer 4 - Flood attacks',
              },
              // {
              //   key: '342',
              //   label: 'DDoS Layer 4 - Amplification attacks',
              // },
              // {
              //   key: '343',
              //   label: 'DDoS Layer 4 - Reflection attacks',
              // },
            ],
          },
          {
            key: '37',
            label: 'Layer 7',
            children: [
              {
                key: '371',
                label: 'DDoS Layer 7 - Flood attacks',
              },
              // {
              //   key: '372',
              //   label: 'DDoS Layer 7 - Amplification attacks',
              // },
              // {
              //   key: '373',
              //   label: 'DDoS Layer 7 - Reflection attacks',
              // },
              {
                key: '374',
                label: 'DDoS Layer 7 - Other attacks',
              },
            ],
          },
        ],
      },
    ],
  },
];
















interface CheckboxItem {
  key: string;
  label: string;
  children?: CheckboxItem[];
}


const getSelectedKeys = (selectedKey: string, scanListCheck: any[]): string[] => {
  const findKeys = (itemsToCheck: any[]): string[] => {
    let keys: string[] = [];

    itemsToCheck.forEach((item) => {
      if (item.key === selectedKey) {
        keys.push(item.key);

        if (item.children && Array.isArray(item.children)) {
          const childKeys = findKeys(item.children);
          keys = [...keys, ...childKeys];
        }
      } else if (item.children && Array.isArray(item.children)) {
        const childKeys = findKeys(item.children);
        keys = [...keys, ...childKeys];
      }
    });

    return keys;
  };

  const selectedKeys = findKeys(scanListCheck);
  const uniqueKeys = [...new Set(selectedKeys)];
  uniqueKeys.sort();

  return uniqueKeys;
};

const getScanType = (scanNumber) => {
  const findKey = (nodes) => {
    for (const node of nodes) {
      if (node.key === scanNumber.toString()) {
        return node.label;
      }
      if (node.children) {
        const childLabel = findKey(node.children);
        if (childLabel) {
          return childLabel;
        }
      }
    }
    return null;
  };

  const label = findKey(scanListCheck);
  return label || 'Invalid scan number';
};


const GotoScannedPage = ({ id }) => {

  // Create the link object with dynamic URL construction
  const link = useLink({
    href: `/scannedPage/${id}`, // Use pathname for dynamic routing in Solito
  });

  return (
    <Button
      size="$4"
      borderRadius="$10"
      {...link}
      // onPress={link.onPress}
    >Scan details</Button>
  );
};
const getScanListItems = (victim) => {
  return victim.scanList.map((scanNumber, index) => (
    <YGroup.Item key={index}>
      <ListItem
        title={getScanType(scanNumber)}
        icon={victim.doneList.includes(scanNumber) ? <DoneIcon /> : <Spinner />}
      />
    </YGroup.Item>
  ));
};

const VictimCard = ({ victim }) => {
  let hostName = "";

  if (Array.isArray(victim.hostName) && victim.hostName.length > 0) {
    const userHostNames = victim.hostName.filter(
      (host) => host.Type === "user"
    );
    hostName = userHostNames.map((host) => host.Name).join(", ");
  }

  return (
    <Card
      elevate
      size="$5"
      animation={'bouncy'}
      scale={0.9}
      hoverStyle={{ scale: 0.975 }}
      pressStyle={{ scale: 0.945 }}
      bordered
    >
      <Card.Header padded>
        {hostName ? (
          <>
            <H2>{hostName}</H2>
            <H4 opacity={"50%"}>{victim.ip}</H4>
          </>
        ) : (
          <H2>{victim.ip}</H2>
        )}
        <Paragraph theme="alt2">
          ID: <strong>{victim.id}</strong>
        </Paragraph>
        <Paragraph theme="alt2">
          Duration: <strong>{victim.duration}</strong> seconds,
          Multi threads: <strong>{victim.threads}</strong> threads/each<br />

          Performed Date: <strong>{victim.scannedDate}</strong>,
          Performed Time: <strong>{victim.startTime}</strong><br />
          <YGroup separator={<Separator />}>
            {getScanListItems(victim)}
          </YGroup>
        </Paragraph>
      </Card.Header>
      <Card.Footer padded>
        <XStack flex={1} />
        <GotoScannedPage id={victim.id} />
      </Card.Footer>
      <Card.Background />
    </Card>
  );
};








export function HomeScreen() {
  const toast = useToastController();
  const [status, setStatus] = useState<'off' | 'submitting' | 'submitted'>('off')


  const statusMessage = (() => {
    switch (status) {
      case 'off':
        return "Start Scan";
      case 'submitting':
        return "Scanning...";
      case 'submitted':
        return "Added Scan."
    }
  })();

  const [victimList, setVictimList] = useState([]);



  const [scanVictim, setScanVictim] = useState(``)
  const [scanDuration, setScanDuration] = useState('')
  const [scanThreads, setScanThreads] = useState('')


  const socket = new WebSocket("wss://ntfy.sh/gsp24ia08-capstone-webapp/ws");
  socket.addEventListener('message', function (event) {
    if(event.data) {
      getData();
    }
  });



  const [checkedKeys, setCheckedKeys] = useState<string[]>(Object.keys(scanListCheck));







  const handleCheckboxChange = (key: string, checked: boolean) => {
    const getChildKeys = (nodes: CheckboxItem[]): string[] => {
      let childKeys: string[] = [];

      for (const node of nodes) {
        childKeys.push(node.key);

        if (node.children) {
          childKeys.push(...getChildKeys(node.children));
        }
      }

      return childKeys;
    };

    // Skip the checking logic if the key is '0'
    if (key === '0') return;

    if (checked) {
      const itemToCheck = scanListCheck[0].children.find(
        (item) => item.key === key
      );

      if (itemToCheck) {
        if (itemToCheck.key.length === 3 || key === '10') {
          const childKeys = getChildKeys([itemToCheck]);
          setCheckedKeys((prevCheckedKeys) => [...new Set([...prevCheckedKeys, ...childKeys])]);
        } else if (itemToCheck.children) {
          const childKeys = getChildKeys(itemToCheck.children);
          setCheckedKeys((prevCheckedKeys) => [...new Set([...prevCheckedKeys, key, ...childKeys])]);
        } else {
          setCheckedKeys((prevCheckedKeys) => [...new Set([...prevCheckedKeys, key])]);
        }
      }
    } else {
      const itemToUncheck = scanListCheck[0].children.find(
        (item) => item.key === key
      );

      if (itemToUncheck) {
        const childKeys = getChildKeys([itemToUncheck]);
        setCheckedKeys((prevCheckedKeys) => prevCheckedKeys.filter((k) => !childKeys.includes(k)));
      }
    }
  };







  const handleSpecialCase = (keys: string[]) => {
    if (keys.includes('0')) {
      const firstChild = scanListCheck[0]?.children?.[0];
      const childrenOf0 = firstChild?.children?.map((item) => item.key) || [];
      return [...new Set([...keys.filter((key) => key !== '0'), ...childrenOf0])];
    }
    return keys;
  };

// Update the setCheckedKeys calls with handleSpecialCase
  const handleCheckboxChangeWithSpecialCase = (key: string, checked: boolean) => {
    if (key === '0') {
      // Handle the special case for key '0' separately
      if (checked) {
        const childrenOf0 = scanListCheck[0]?.children?.[0]?.children?.map((item) => item.key) || [];
        setCheckedKeys([...new Set([...checkedKeys, ...childrenOf0])]);
      } else {
        const childrenOf0 = scanListCheck[0]?.children?.[0]?.children?.map((item) => item.key) || [];
        setCheckedKeys(checkedKeys.filter((k) => !childrenOf0.includes(k)));
      }
    } else {
      // Handle other cases as before
      handleCheckboxChange(key, checked);
    }
  };





  useEffect(() => {
    setCheckedKeys(getAllKeys(scanListCheck));
  }, []);

  function CheckboxWithLabel({
                               label,
                               value,
                               defaultChecked = false,
                               ...checkboxProps
                             }: CheckboxProps & { label?: string; value: string; defaultChecked?: boolean }) {
    const id = label;

    return (
      <XStack width={300} alignItems="center" space="$4">
        <Checkbox
          id={id}
          size={'$4'}
          onCheckedChange={(checked) => handleCheckboxChangeWithSpecialCase(value, checked)}
          {...checkboxProps}
        >
          <Checkbox.Indicator>
            <CheckIcon />
          </Checkbox.Indicator>
        </Checkbox>

        <Label size="$4" htmlFor={id}>
          {label}
        </Label>
      </XStack>
    );
  }

  const CheckboxTree = ({
                          items,
                          checkedKeys,
                          onCheckboxChange,
                        }: {
    items: CheckboxItem[];
    checkedKeys: string[];
    onCheckboxChange: (keys: string[]) => void;
  }) => {
    const [expandedKeys, setExpandedKeys] = useState<string[]>(["0"]);

    // Use the useEffect hook to update the expandedKeys state when checkedKeys changes
    useEffect(() => {
      // const initialExpandedKeys = getInitialExpandedKeys(items);
      const initialExpandedKeys = ["0"];
      setExpandedKeys(initialExpandedKeys);
    }, [items, checkedKeys]);

    const handleCheckboxChange = (key: string, checked: boolean) => {
      const getChildKeys = (nodes: CheckboxItem[]): string[] => {
        let childKeys: string[] = [];

        for (const node of nodes) {
          childKeys.push(node.key);

          if (node.children) {
            childKeys.push(...getChildKeys(node.children));
          }
        }

        return childKeys;
      };

      if (checked) {
        const itemToCheck = scanListCheck[0].children.find(
          (item) => item.key === key
        );

        if (itemToCheck) {
          if (itemToCheck.key.length === 3 || key === '10') {
            const childKeys = getChildKeys([itemToCheck]);
            setCheckedKeys([...checkedKeys, ...childKeys]);
          } else if (itemToCheck.children) {
            const childKeys = getChildKeys(itemToCheck.children);
            setCheckedKeys([...checkedKeys, key, ...childKeys]);
          } else {
            setCheckedKeys([...checkedKeys, key]);
          }
        }
      } else {
        const itemToUncheck = scanListCheck[0].children.find(
          (item) => item.key === key
        );

        if (itemToUncheck) {
          if (itemToUncheck.key.length === 3 || key === '10') {
            const childKeys = getChildKeys([itemToUncheck]);
            setCheckedKeys(checkedKeys.filter((k) => !childKeys.includes(k)));
          } else if (itemToUncheck.children) {
            const childKeys = getChildKeys(itemToUncheck.children);
            setCheckedKeys(checkedKeys.filter((k) => !childKeys.includes(k) && k !== key));
          } else {
            setCheckedKeys(checkedKeys.filter((k) => k !== key));
          }
        }
      }
    };



    const toggleExpand = (key: string) => {
      setExpandedKeys((prevExpandedKeys) =>
        prevExpandedKeys.includes(key)
          ? prevExpandedKeys.filter((k) => k !== key)
          : [...prevExpandedKeys, key]
      );
    };

    const isChecked = (key: string) => checkedKeys.includes(key);

    const renderItem = (item: CheckboxItem) => (
      <div key={item.key}>
        <div onClick={() => toggleExpand(item.key)}>
          <CheckboxWithLabel
            label={item.label}
            value={item.key}
            checked={isChecked(item.key)}
            onChange={(event) => handleCheckboxChange(item.key, event.target.checked)}
          />
        </div>
        {item.children && expandedKeys.includes(item.key) && (
          <div style={{ marginLeft: 20 }}>
            {item.children.map(renderItem)}
          </div>
        )}
      </div>
    );

    return <div>{items.map(renderItem)}</div>;
  };

  const getInitialExpandedKeys = (items: CheckboxItem[]): string[] => {
    const keys: string[] = [];

    const traverseItems = (itemsToTraverse: CheckboxItem[]) => {
      itemsToTraverse.forEach((item) => {
        keys.push(item.key);
        if (item.children) {
          traverseItems(item.children);
        }
      });
    };

    traverseItems(items);
    return keys;
  };







  const formattedCheckedKeys = checkedKeys.filter(key => {
    // Check if the key is a single or double-digit number, but not '10'
    const isShortNumber = /^(?!10$)\d{1,2}$/.test(key);
    return !isShortNumber;
  });

  const fetchData = async () => {
    try {
      const response = await fetch(`${backendUrl}/scan`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          scan: scanVictim,
          scanType: formattedCheckedKeys,
          duration: scanDuration || 10,
          threads: scanThreads || 100
        }),
      });

      if (!response.ok) {
        console.error('Failed to fetch data: POST SCAN: ', response);
        toast.show('🔴Oopsy!', {
          message: 'Failed to fetch data at Upload Scan Victim',
        })
      }
      toast.show('💡Added a new scan!', {
        message: `🔃You got some hating on ${scanVictim}, right 👀?`,
      })
      const data = await response.json();
      console.log("Scanned data: ", data);
      getData(); // Assuming getData is defined elsewhere
      toast.show(`💡Walahh, ID ${data.id.toString()} reconnaissance step was done!`, {
        message: '🔃Reload this page to see the details report',
      })
    } catch (error) {
      console.error('Error fetching report data:', error);
    }
  }

  // Call the fetchData function when status is 'submitting'
  if (status === 'submitting') {
    fetchData().then(()=> setStatus(('off')));
  }



  const getData = async () => {
    fetch(`${backendUrl}/scans`)
      .then(res => res.json())
      .then((data) => {
        setVictimList(data)
        console.log("victim list:", victimList);
      })
      .catch((err) => {
        console.log('error GET /scans: ', err)
      })
  }

  useEffect(() => {
    getData()
  }, [])



  // @ts-ignore
  // @ts-ignore
  return (
    <YStack f={1} jc="center" ai="center" p="$4" space>
      <YStack space="$4" bc="$background">
        <br /><br />
        <H1 ta="left"> Automating DoS/DDoS Pentest </H1>
        <br />
        <Paragraph ta="left">
          💻 This website was created with the purpose of being a platform for presenting the automation in Bench Testing DOS/DDOS attack steps by our group.
          Feel free to use and experiment, as well as learn with us.
          <br />
          ✋✋ <strong>Disclaimer:</strong> With this website, we use real-life open source tools that can potentially harm real systems.
          Please use with caution and ensure you use it for the right purposes.
          Stay ethical! 😇
        </Paragraph>

        <Separator />
        <Paragraph ta="center">
          Made with 💖, by <strong>Capstone Project Group IA08 - Spring 2024 FPT University</strong>
        </Paragraph>
      </YStack>
      <XStack
        maxWidth={'100%'}
        alignContent={'center'}
        space="$2"
      >
        <Form
          alignItems="left"
          minWidth={300}
          gap="$3"
          onSubmit={() => setStatus('submitting')}
          borderWidth={1}
          borderRadius="$4"
          backgroundColor="$background"
          borderColor="$borderColor"
          padding="$8"
        >
          <H4>Choose perform steps:</H4>
          {/*<Paragraph>Checked keys: {checkedKeys.join(', ')}</Paragraph>*/}

          <CheckboxTree
            items={scanListCheck}
            checkedKeys={checkedKeys}
            onCheckboxChange={handleCheckboxChange}
          />
          <SizableText theme="alt1" size={'$4'}>😱Report file can only export when it perform full scan.😱</SizableText>

        </Form>

        <Form
          alignItems="center"
          minWidth={300}
          gap="$3"
          onSubmit={() => setStatus('submitting')}
          borderWidth={1}
          borderRadius="$4"
          backgroundColor="$background"
          borderColor="$borderColor"
          padding="$8"
        >
          <H4>Start (legally) doing something here:</H4>
          <XStack
            maxWidth={'100%'}
            alignContent={'center'}
            space="$3"
          >

            <Input
              borderWidth={2}
              size="$4"
              width={'$20'}
              placeholder={'Give me the Domain / Address ...'}
              placeholderTextColor={'lightgray'}
              onChange={e => {
                // @ts-ignore
                setScanVictim(e.target.value)
              }}
            />
            <Form.Trigger asChild disabled={status !== 'off'}>

              <Tooltip placement={'top-start'}>
                <Tooltip.Trigger>
                  <Button
                    icon={status === 'submitting' ? () => <Spinner /> : undefined}
                    onPress={() => setStatus('submitting')} // Change this line
                    disabled={!scanVictim}
                  >
                    {statusMessage}
                  </Button>
                </Tooltip.Trigger>
                <Tooltip.Content
                  enterStyle={{ x: 0, y: -5, opacity: 0, scale: 0.9 }}
                  exitStyle={{ x: 0, y: -5, opacity: 0, scale: 0.9 }}
                  scale={1}
                  x={0}
                  y={0}
                  opacity={1}
                  animation={[
                    'quick',
                    {
                      opacity: {
                        overshootClamping: true,
                      },
                    },
                  ]}
                >
                  <Tooltip.Arrow />
                  <Paragraph size="$2" lineHeight="$1">
                    Input Victim first
                  </Paragraph>
                </Tooltip.Content>
              </Tooltip>
            </Form.Trigger>
          </XStack>


          <br />
          <H4>Attack parameters:</H4>
          <XStack space={'$4'}>
            <YStack space={'$2'}>
              <Paragraph><strong>Attack duration:</strong> (in seconds)</Paragraph>
              <Input
                placeholder={('default = 10')}
                disabled={!scanVictim}
                keyboardType={'numeric'}
                onChange={e => {
                  // @ts-ignore
                  setScanDuration(e.target.value)
                }}
              />
            </YStack>
            <YStack space={'$2'}>
              <Paragraph><strong>Attack threads:</strong></Paragraph>
              <Input
                placeholder={'default = 100'}
                disabled={!scanVictim}
                keyboardType={'numeric'}
                onChange={e => {
                  // @ts-ignore
                  setScanThreads(e.target.value)
                }}
              />
            </YStack>
          </XStack>
          <br />



        </Form>
      </XStack>
      <H1 ta="left">Scanned List</H1>

      <YStack space={20}>
        {victimList.length > 0 ? (
          victimList
            .sort((a, b) => b.id - a.id)
            .filter((victim) => victim.id !== undefined)
            .map((victim, index) => (
            <VictimCard key={index} victim={victim} />
          ))
        ) : (
          <Paragraph alignItems={'center'}>
            Nothing to display. Start a Scan to display here.
          </Paragraph>
        )}
      </YStack>
    </YStack>
  )
}

