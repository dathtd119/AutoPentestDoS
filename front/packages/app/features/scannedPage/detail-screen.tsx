import {
  H1, H2, H3, H4, H5, H6,
  YGroup, XGroup,
  ListItem,
  Paragraph, Text,
  ScrollView,
  Separator,
  YStack, XStack,
  Accordion,
  Square,
  Button,
  Popover,  Adapt, Label
} from '@my/ui'
import type { PopoverProps } from 'tamagui'
import { useLink} from 'solito/link'
import { useParams } from 'solito/navigation'
import React, {useState, useEffect} from 'react'
import { View } from 'react-native';

import {
  ChevronDown, ChevronUp,
  ShieldCheck as GoodIcon, ShieldX as BadIcon,
  DownloadCloud as ReportDownload,
  Info as cvesInfo,
  X
} from '@tamagui/lucide-icons'
import { Spinner } from 'tamagui'

const BACKENDURL = 'http://localhost:3001'; // Replace with your server URL


const badColor = 'red';
const goodColor = 'green';

function ShowOpenPorts(portList) {
  // Filter ports by name
  const tcpwrappedPorts = portList.filter(port => port.name === "tcpwrapped");

  // Filter out tcpwrapped ports
  const otherPorts = portList.filter(port => port.name !== "tcpwrapped");





  return (
    <Accordion overflow="hidden" width="$21" type="multiple">
      <Accordion.Item value="a1">
        <Accordion.Trigger flexDirection="row" justifyContent="space-between">
          {({ open }) => (
            <>
              <strong>Open Ports and running service:</strong>
              <br />
              <Square animation="quick" rotate={open ? '180deg' : '0deg'}>
                <ChevronDown size="$1" />
              </Square>
            </>
          )}
        </Accordion.Trigger>
        <Accordion.Content>
          <YGroup separator={<Separator />}>
            {otherPorts.map(port => (
              // render port
              <YGroup.Item key={port.portId}>
                <ListItem
                  title={
                    <strong>{port.portId + ' (' + port.name.toUpperCase() + ')'}</strong>
                  }
                  subTitle={
                    <YStack
                      opacity={'80%'}
                    >
                      <Paragraph>Product: {port.product || 'null'}, Version: {port.version || 'null'}</Paragraph>

                      <br/>
                      {port.cve.length > 0 && (
                      <YStack>
                        <H6>
                          Potential Vulnerabilites
                        </H6>
                        <Paragraph>
                           Count: <strong>{port.cve.length}</strong>
                        </Paragraph>
                        <Paragraph>
                           Average CVSS Score:
                          <strong> {
                            port.cve.length > 0 ?
                              (port.cve.reduce((sum, cve) => cve.Details && cve.Details.length > 0 && cve.Details[0].cvss_score ?
                                sum + cve.Details[0].cvss_score : sum, 0) / port.cve.filter(cve => cve.Details && cve.Details.length > 0 && cve.Details[0].cvss_score).length).toFixed(2) : 'N/A'}
                          </strong>
                        </Paragraph>
                        {port.cve.map((cve, index) => (
                          <Paragraph key={index}>
                            {'\n'}  {'\u2022'} {cve.Codes} - {cve.Title || 'N/A'} -
                            <strong> CVSS: {cve.Details[0].cvss_metrics.cvss2.score}</strong>
                          </Paragraph>
                        ))}
                      </YStack>
                    )}
                    </YStack>
                  }
                />
              </YGroup.Item>
            ))}

            {tcpwrappedPorts.map(port => (
              // render tcpwrapped port at bottom
              <YGroup.Item key={port.portId}>
                <ListItem
                  title={port.portId + " (" + port.name.toUpperCase() + ")"}
                  subTitle={
                    <>
                      <Paragraph>Product: {port.product || 'null'}, Version: {port.version || 'null'}, Average Score: {port.cve.length > 0 ? (port.cve.reduce((sum, cve) => cve.Details && cve.Details.length > 0 && cve.Details[0].cvss_score ? sum + cve.Details[0].cvss_score : sum, 0) / port.cve.filter(cve => cve.Details && cve.Details.length > 0 && cve.Details[0].cvss_score).length).toFixed(2) : 'N/A'}</Paragraph>
                      {port.cve.length > 0 && (
                        <>
                          <strong>{'\n'}Potential Vulnerabilities:</strong>
                          {port.cve.map((cve, index) => (
                            <Paragraph key={index}>
                              {'\n'}{cve.Codes} - {cve.Details?.[0]?.cve_description || 'N/A'}
                            </Paragraph>
                          ))}
                        </>
                      )}
                    </>
                  }
                />
              </YGroup.Item>
            ))}
          </YGroup>
        </Accordion.Content>
      </Accordion.Item>
    </Accordion>

  )
}


const AttackList = ({ DetailAttackDoS, DetailAttackDDoS, layer, tool, attackType }) => {

  const calculateAverageScore = (attackData) => {
    let totalScore = 0;
    let scoreCount = 0;

    const extractScores = (data) => {
      if (Array.isArray(data)) {
        data.forEach((item) => extractScores(item));
      } else if (typeof data === 'object') {
        for (const key in data) {
          if (key === layer) {
            const layerData = data[key];
            console.log("layerData :", layerData);
            layerData.forEach((toolData) => {
              for (const toolKey in toolData) {
                if (toolKey === tool) {
                  const toolAttackData = toolData[toolKey];
                  console.log("toolAttackData: ", toolAttackData);
                  for (const attackTypeKey in toolAttackData) {
                    if (attackTypeKey === attackType) {
                      const attackTypeData = toolAttackData[attackTypeKey];
                      console.log("attackTypeData: ", attackTypeData);
                      Object.values(attackTypeData).forEach((value) => extractScores(value));
                    }
                  }
                }
              }
            });
          }
        }
      } else if (typeof data === 'number') {
        totalScore += data;
        scoreCount++;
      }
    };

    extractScores(attackData);

    if (scoreCount === 0) {
      return 'N/A';
    }

    return (totalScore / scoreCount).toFixed(2);
  };



  const renderAttackResult = (layerData, selectedTool, selectedAttackType) => {
    if (!layerData || !layerData[selectedTool]) {
      return null; // Return null if layerData is falsy or the tool is not found
    }

    const toolAttackData = layerData[selectedTool][selectedAttackType];

    if (!toolAttackData) {
      return null; // Return null if the attackType is not found in the tool object
    }

    return (
      <View>
        <YGroup>
          {Object.entries(toolAttackData).map(([toolType, attackData]) => (
            <YGroup.Item key={`${selectedTool}-${toolType}`}>
              <ListItem
                title={toolType}
                icon={
                  attackData.success ? (
                    <BadIcon color={badColor} size={"$2"} />
                  ) : (
                    <GoodIcon color={goodColor} size={"$2"} />
                  )
                }
                subTitle={

                  attackData
                    ? (
                      <Paragraph opacity={"0.7"} size={"$4"}>
                        Average Ping: {attackData.avgPing} ms,
                        Max Ping: {attackData.maxPing} ms,
                        Packet Loss: {
                        attackData.packetLossPercentage.toString().includes('.')
                          ? attackData.packetLossPercentage.toFixed(3)
                          : attackData.packetLossPercentage
                      }%<br/>Score: {attackData.score}
                      </Paragraph>
                    )
                    : 'No result data available'
                }
              />
            </YGroup.Item>
          ))}
        </YGroup>
      </View>
    );
  };

  return (
    <View>
      <H6>Average score: </H6>
      <br />
      <H4>{attackType} Attacks</H4>
      <XStack>
        <YGroup>
          <br />
          <H5>DoS</H5>
          <br />
          {DetailAttackDoS && DetailAttackDoS.result && (
            DetailAttackDoS.result.map((layerData, index) => {
              const selectedLayerDoS = layerData[layer]

              if (!selectedLayerDoS || !Array.isArray(selectedLayerDoS) || selectedLayerDoS.length === 0) {
                return null
              }

              return renderAttackResult(selectedLayerDoS[0], tool, attackType)
            })
          )}
        </YGroup>
        <Separator alignSelf="stretch" vertical marginHorizontal={20} />
        <YGroup>
          <br />
          <H5>DDoS</H5>
          <br />
          {DetailAttackDDoS && DetailAttackDDoS.result && (
            DetailAttackDDoS.result.map((layerData, index) => {
              const selectedLayerDDoS = layerData[layer]

              if (!selectedLayerDDoS || !Array.isArray(selectedLayerDDoS) || selectedLayerDDoS.length === 0) {
                return null
              }

              return renderAttackResult(selectedLayerDDoS[0], tool, attackType)
            })
          )}
        </YGroup>
      </XStack>
    </View>
  );
};


const renderInitDetails = (initPingDetails, isLoading) => {
  if (!isLoading) {
    return (
      <XGroup>
        <Paragraph>
          <Spinner />
          Loading Ping Details...
        </Paragraph>
      </XGroup>
    );
  }

  if (initPingDetails) {
    return (
      <>
        <Paragraph>
          <Text> {'\u2022'} Min: <strong>{initPingDetails.minPing} ms</strong></Text> ,<Text> Average: <strong>{initPingDetails.avgPing} ms</strong></Text>, <Text> Max: <strong>{initPingDetails.maxPing} ms</strong></Text>
        </Paragraph>
        <Paragraph>
          <Text> {'\u2022'} Loss Packet
            Percentage: <strong>{initPingDetails.packetLossPercentage} %</strong></Text>
        </Paragraph>
      </>
    );
  }

  return <Paragraph>No Ping Details available</Paragraph>;
};




export function DetailScreen() {
  const params = useParams();
  const id = params.id;
  console.log("params: ", params);

  const goHome = useLink({
    href: '/',
  })
  const [detailRecon, setDetailRecon] = useState< {} | null >(null)
  const [detailAttackDoS, setDetailAttackDoS] = useState< {} | null >(null)
  const [detailAttackDDoS, setDetailAttackDDoS] = useState< {} | null >(null)
  const [initPingDetails, setInitPingDetails] = useState< {} | null >(null)
  const [initGetDetails, setInitGetDetails] = useState< {} | null >(null)

  const [isLoadingRecon, setIsLoadingRecon] = useState(true);
  const [isLoadingAttackDoS, setIsLoadingAttackDoS] = useState(true);
  const [isLoadingAttackDDoS, setIsLoadingAttackDDoS] = useState(true);
  const [isLoadingInitPingDetails, setIsLoadingInitPingDetails] = useState(true);

  const [showCVESheet, setShowCVESheet] = useState(false);

  const [openCVESheet, setOpenCVESheet] = useState(false)
  const [position, setPosition] = useState(0)


  const getData = async () => {
    console.log(`Getting ID ${id} scan details...`)


    //RECON
    fetch(`${BACKENDURL}/scan/${id}/recon`)
      .then((res) => res.json())
      .then((data) => {
        setDetailRecon(data);
        setIsLoadingRecon(false);
      })
      .catch((err) => {
        console.log("error GET /scans: ", err);
        setIsLoadingRecon(false);
      });


    //Init Ping
    fetch(`${BACKENDURL}/scan/${id}/initPing`)
      .then((res) => res.json())
      .then((data) => {
        setInitPingDetails(data);
        console.log("Init ping:", initPingDetails);
        setIsLoadingAttackDoS(false);
      })
      .catch((err) => {
        console.log("error GET initPing: ", err);
        setIsLoadingAttackDoS(false);
      })

    //Init Get
    fetch(`${BACKENDURL}/scan/${id}/initGet`)
      .then((res) => res.json())
      .then((data) => {
        setInitGetDetails(data);
        console.log("Init get:", initGetDetails);
        setIsLoadingAttackDoS(false);
      })
      .catch((err) => {
        console.log("error GET initGet: ", err);
        setIsLoadingAttackDoS(false);
      })

    //DoS
    fetch(`${BACKENDURL}/scan/${id}/attack/dos`)
      .then((res) => {
        if (res.ok) {
          return res.json();
        } else {
          throw new Error(`HTTP error ${res.status}`);
        }
      })
      .then((data) => {
        setDetailAttackDoS(data);
        console.log("attack dos: ", data);
        setIsLoadingAttackDoS(false);
      })
      .catch((err) => {
        console.log(`error GET /scan/${id}/attack/dos: `, err);
        // Handle the error here, e.g., show an error message to the user
        setIsLoadingAttackDoS(false);
      });

    //DDoS
    fetch(`${BACKENDURL}/scan/${id}/attack/ddos`)
      .then((res) => {
        if (res.ok) {
          return res.json();
        } else {
          throw new Error(`HTTP error ${res.status}`);
        }
      })
      .then((data) => {
        setDetailAttackDDoS(data);
        console.log("attack ddos: ", data);
        setIsLoadingAttackDDoS(false);
      })
      .catch((err) => {
        console.log(`error GET /scan/${id}/attack/ddos: `, err);
        // Handle the error here, e.g., show an error message to the user
        setIsLoadingAttackDDoS(false);
      });
  }


  useEffect(() => {
    getData();
  }, []);


  const socket = new WebSocket("wss://ntfy.sh/gsp24ia08-capstone-webapp/ws");
  socket.addEventListener('message', function (event) {
    if(event.data) {
      console.log("NTFY: ", event.data);
      // toast.show('Wahlah!', {
      //   message: event.data.message,
      // })
    }
    getData();
  });


  if (isLoadingRecon) {
    return <H1><Spinner/> Loading...</H1>;
  }

  if (!detailRecon) {
    return <H1>Error fetching data</H1>;
  }


  const handleDownload = async (id,fileType) => {
    try {
      const response = await fetch(`${BACKENDURL}/scan/${id}/report`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ type: fileType }),
      });
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${id}-report.${fileType}`;
      document.body.appendChild(a);
      a.click();
      a.remove();
    } catch (error) {
      console.error('Error downloading report:', error);
    }
  };


  function GetReportButton ({
                           Icon,
                           Name,
                           ...props
                         }: PopoverProps & { Icon?: any; Name?: string }) {
    return (

    <Popover size="$5" allowFlip {...props}>
      <Popover.Trigger asChild>
        <Button
          size="$6"
          borderRadius="$10"
          icon={ReportDownload}
          // onPress={handleDownload}
          style={{
            position: 'absolute',
            top: 16,
            right: 16,
            zIndex: 1,
          }}
        >
          Get the report
        </Button>
      </Popover.Trigger>

      <Adapt when="sm" platform="touch">
        <Popover.Sheet modal dismissOnSnapToBottom>
          <Popover.Sheet.Frame padding="$4">
            <Adapt.Contents />
          </Popover.Sheet.Frame>
          <Popover.Sheet.Overlay
            animation="lazy"
            enterStyle={{ opacity: 0 }}
            exitStyle={{ opacity: 0 }}
          />
        </Popover.Sheet>
      </Adapt>

      <Popover.Content
        borderWidth={1}
        borderColor="$borderColor"
        enterStyle={{ y: -10, opacity: 0 }}
        exitStyle={{ y: -10, opacity: 0 }}
        elevate
        animation={[
          'quick',
          {
            opacity: {
              overshootClamping: true,
            },
          },
        ]}
      >
        <Popover.Arrow borderWidth={1} borderColor="$borderColor" />

        <YStack space="$3">
          <XStack space="$3">
            <Label size="$3" >
              Choosing report extension
            </Label>
          </XStack>

          <Popover.Close >
            <XStack
              flex={1}
              space="$6"
              padding={"$4"}>
              <Button
                size="$3"
                onPress={() => handleDownload(id,'docx')}
              >
                DOCX
              </Button>
              <Button
                size="$3"
                onPress={() => handleDownload(id,'pdf')}
              >
                PDF
              </Button>
            </XStack>


          </Popover.Close>
        </YStack>
      </Popover.Content>
    </Popover>

    );
  };





  // @ts-ignore
  return (
    <YStack
      f={1}
      jc="top"
      ai="center"
    >

      <YStack
        fullscreen={true}
        ai="center"
        flex={1}
        flexWrap="wrap-reverse"
        gap="$5"
      >

        <ScrollView
          maxHeight={'100%'}
          width={'85%'}
          padding="$4"
          borderRadius="$4"
        >
          <br /><br />
          <XGroup
          >
            <H1>DoS/DDoS Pen-test Report</H1>

            {initPingDetails !== null && initGetDetails !== null && detailAttackDoS !== null && detailAttackDDoS !== null && (
                <GetReportButton placement="bottom" Icon={ChevronDown} Name="bottom-popover"/>
              )}


          </XGroup>
          <br /><br />
          <H2>Reconnaissance Results</H2>
          <br />
          <Paragraph>
            <strong>Victim Information:</strong><br />
            {detailRecon.hostName ? (
              <>
                <Paragraph>Host name: <strong>{detailRecon.hostName}</strong></Paragraph><br />
                <Paragraph>IP Address: <strong>{detailRecon.address}</strong></Paragraph>
              </>
            ) : (
              <Paragraph>IP Address: <strong>{detailRecon.address}</strong></Paragraph>
            )}<br/>
            Open ports: <strong>{detailRecon.ports.length}</strong> ports
            <br /><br />

            <Text>
              {/* Display the count of open ports */}

            </Text>
            {ShowOpenPorts(detailRecon.ports)}<br />
            <br />
          </Paragraph>


          <H2>Exploitation Results</H2><br />
          <H6>Initialized Ping (layer 3 -4):</H6>
          {renderInitDetails(initPingDetails, isLoadingInitPingDetails)}

          <br />
          <H3>Layer 3 - Network Layer</H3>
          <AttackList
            DetailAttackDoS={detailAttackDoS}
            DetailAttackDDoS={detailAttackDDoS}
            layer="Layer 3"
            tool="HPing3"
            attackType="Flood"
          />

          <br />

          <H3>Layer 4 - Transport Layer</H3>
          <AttackList
            DetailAttackDoS={detailAttackDoS}
            DetailAttackDDoS={detailAttackDDoS}
            layer="Layer 4"
            tool="HPing3"
            attackType="Flood"
          />
          <br />
          <H3>Layer 7 - Application Layer</H3>
          <H6>Initialized Application response (layer 7):</H6>
          {renderInitDetails(initGetDetails, isLoadingInitPingDetails)}
          <br />
          <AttackList
            DetailAttackDoS={detailAttackDoS}
            DetailAttackDDoS={detailAttackDDoS}
            layer="Layer 7"
            tool="MHDDoS"
            attackType="Flood"
          />
          <br />
          <AttackList
            DetailAttackDoS={detailAttackDoS}
            DetailAttackDDoS={detailAttackDDoS}
            layer="Layer 7"
            tool="MHDDoS"
            attackType="Other"
          />

          <br /><br />
          <H2>Recommendations</H2>
          <H4>Reconnaissance:</H4>
          <ul>
            <Paragraph>Gather more detailed information on services and applications running on open ports.</Paragraph>
            <Paragraph> Identify potential vulnerabilities in the discovered services.</Paragraph>
          </ul>

        </ScrollView>
      </YStack>
    </YStack>
  )
}

